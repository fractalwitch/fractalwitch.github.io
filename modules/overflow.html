<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  overflow: hidden;
  background: #000;
  font-family: 'Courier New', monospace;
  cursor: none;
  touch-action: none; /* Prevent scrolling on mobile */
}
canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
}
.intensity-bar {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 300px;
  max-width: 80%;
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  overflow: hidden;
  pointer-events: none;
}
.intensity-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff);
  width: 0%;
  transition: width 0.1s;
  box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
}
.state-text {
  position: absolute;
  top: 30px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.7);
  font-size: 18px;
  letter-spacing: 4px;
  text-shadow: 0 0 20px rgba(255, 255, 255, 0.9);
  pointer-events: none;
  transition: all 0.3s;
  text-align: center;
  width: 100%;
}
.cursor {
  position: absolute;
  width: 30px;
  height: 30px;
  border: 2px solid rgba(255, 255, 255, 0.8);
  border-radius: 50%;
  pointer-events: none;
  transform: translate(-50%, -50%);
  transition: width 0.1s, height 0.1s, border-color 0.1s;
  box-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
  z-index: 10;
}
/* Hide custom cursor on touch devices to avoid confusion */
@media (hover: none) and (pointer: coarse) {
    .cursor {
        display: none;
    }
}
.pulse-ring {
  position: absolute;
  width: 30px;
  height: 30px;
  border: 2px solid rgba(255, 0, 255, 0.6);
  border-radius: 50%;
  pointer-events: none;
  transform: translate(-50%, -50%);
  animation: pulse-out 1s infinite;
  z-index: 9;
}
@keyframes pulse-out {
  0% {
    width: 30px;
    height: 30px;
    opacity: 1;
  }
  100% {
    width: 100px;
    height: 100px;
    opacity: 0;
  }
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="cursor" id="cursor"></div>
<div class="pulse-ring" id="pulseRing"></div>
<div class="state-text" id="stateText">∞ TOUCH TO BEGIN ∞</div>
<div class="intensity-bar">
  <div class="intensity-fill" id="intensityFill"></div>
</div>

<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');

// Handle High DPI displays
function resize() {
    c.width = window.innerWidth;
    c.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

let mouseX = c.width / 2;
let mouseY = c.height / 2;
let targetX = mouseX;
let targetY = mouseY;
let isPressed = false;
let intensity = 0;
let targetIntensity = 0;
let frequency = 1;
let time = 0;
let waves = [];
let particles = [];
let tendrils = [];
let smokePaths = [];
let buildPhase = 0;

const states = [
  '∞ BUILDING ∞',
  '∞ PULSING ∞',
  '∞ TWISTING ∞',
  '∞ CASCADING ∞',
  '∞ OVERFLOW ∞',
  '∞ ∞ ∞'
];

class Wave {
  constructor(x, y, intensity) {
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.maxRadius = 100 + intensity * 400;
    this.opacity = 0.8;
    this.speed = 2 + intensity * 8;
    this.hue = 280 + Math.sin(time) * 80;
    this.frequency = frequency;
  }
  
  update() {
    this.radius += this.speed;
    this.opacity *= 0.97;
    return this.opacity > 0.01 && this.radius < this.maxRadius;
  }
  
  draw() {
    ctx.strokeStyle = `hsla(${this.hue}, 80%, 60%, ${this.opacity})`;
    ctx.lineWidth = 2 + intensity * 4;
    ctx.shadowBlur = 20;
    ctx.shadowColor = `hsla(${this.hue}, 100%, 50%, ${this.opacity})`;
    
    // Modulated shape
    ctx.beginPath();
    for(let i = 0; i <= 360; i += 10) {
      let angle = (i * Math.PI) / 180;
      let modulation = Math.sin(i * this.frequency + time * 3) * 10 * intensity;
      let r = this.radius + modulation;
      let x = this.x + Math.cos(angle) * r;
      let y = this.y + Math.sin(angle) * r;
      if(i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }
}

class Particle {
  constructor(x, y, intensity) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * (2 + intensity * 10);
    this.vy = (Math.random() - 0.5) * (2 + intensity * 10);
    this.life = 1;
    this.decay = 0.98 - intensity * 0.02;
    this.hue = 280 + Math.random() * 80;
    this.size = 2 + Math.random() * 3 + intensity * 3;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.98;
    this.vy *= 0.98;
    this.life *= this.decay;
    return this.life > 0.01;
  }
  
  draw() {
    ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, ${this.life})`;
    ctx.shadowBlur = 15;
    ctx.shadowColor = `hsla(${this.hue}, 100%, 50%, ${this.life})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Tendril {
  constructor(x, y, angle, intensity) {
    this.segments = [];
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.length = 50 + intensity * 200;
    this.speed = 3 + intensity * 7;
    this.hue = 280 + Math.sin(time + angle) * 80;
    this.opacity = 0.7 + intensity * 0.3;
    this.twist = Math.random() * 0.2;
    
    for(let i = 0; i < 30; i++) {
      this.segments.push({
        x: x,
        y: y
      });
    }
  }
  
  update() {
    this.angle += this.twist * intensity;
    let targetX = this.x + Math.cos(this.angle) * this.speed;
    let targetY = this.y + Math.sin(this.angle) * this.speed;
    
    this.segments.unshift({x: targetX, y: targetY});
    if(this.segments.length > 30) this.segments.pop();
    
    this.opacity *= 0.98;
    return this.opacity > 0.01;
  }
  
  draw() {
    ctx.strokeStyle = `hsla(${this.hue}, 70%, 50%, ${this.opacity})`;
    ctx.lineWidth = 2 + intensity * 3;
    ctx.shadowBlur = 15;
    ctx.shadowColor = `hsla(${this.hue}, 100%, 60%, ${this.opacity})`;
    
    ctx.beginPath();
    ctx.moveTo(this.segments[0].x, this.segments[0].y);
    for(let seg of this.segments) {
      ctx.lineTo(seg.x, seg.y);
    }
    ctx.stroke();
  }
}

class SmokePath {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 0.5;
    this.vy = -0.5 - Math.random() * 1.5;
    this.size = 20 + Math.random() * 40;
    this.opacity = 0.6;
    this.hue = 280 + Math.random() * 40;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotationSpeed = (Math.random() - 0.5) * 0.05;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.99;
    this.vy *= 0.99;
    this.size *= 1.02;
    this.opacity *= 0.97;
    this.rotation += this.rotationSpeed;
    return this.opacity > 0.01;
  }
  
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    
    let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
    gradient.addColorStop(0, `hsla(${this.hue}, 60%, 50%, ${this.opacity})`);
    gradient.addColorStop(0.5, `hsla(${this.hue}, 50%, 40%, ${this.opacity * 0.5})`);
    gradient.addColorStop(1, `hsla(${this.hue}, 40%, 30%, 0)`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
}

function spawnEffects(x, y, amount) {
  // Waves
  if(intensity > 0.3) {
    waves.push(new Wave(x, y, intensity));
  }
  
  // Particles
  for(let i = 0; i < amount * intensity * 5; i++) {
    particles.push(new Particle(x, y, intensity));
  }
  
  // Tendrils
  if(intensity > 0.5) {
    for(let i = 0; i < 8; i++) {
      let angle = (Math.PI * 2 * i) / 8 + time;
      tendrils.push(new Tendril(x, y, angle, intensity));
    }
  }
  
  // Smoke
  if(intensity > 0.7) {
    for(let i = 0; i < 3; i++) {
      smokePaths.push(new SmokePath(x, y));
    }
  }
}

function updateState() {
  let stateIndex = Math.min(Math.floor(intensity * states.length), states.length - 1);
  document.getElementById('stateText').textContent = states[stateIndex];
  
  let stateText = document.getElementById('stateText');
  // Clamp font size to be reasonable
  stateText.style.fontSize = Math.min(60, (18 + intensity * 20)) + 'px';
  stateText.style.textShadow = `0 0 ${20 + intensity * 40}px rgba(255, 255, 255, ${0.5 + intensity * 0.5})`;
}

function animate() {
  // Trail effect
  ctx.fillStyle = `rgba(0, 0, 0, ${0.15 - intensity * 0.1})`;
  ctx.fillRect(0, 0, c.width, c.height);
  
  time += 0.05 + intensity * 0.1;
  buildPhase += 0.01;
  
  // Smooth intensity changes
  intensity += (targetIntensity - intensity) * 0.1;
  
  // Update frequency based on build phase
  frequency = 1 + Math.sin(buildPhase) * 3 * intensity;
  
  // Lerp mouse position
  mouseX += (targetX - mouseX) * 0.1;
  mouseY += (targetY - mouseY) * 0.1;
  
  // Auto-spawn when pressed
  if(isPressed && Math.random() < 0.3 + intensity * 0.7) {
    spawnEffects(mouseX, mouseY, 1);
  }
  
  // Overflow effect
  if(intensity > 0.9) {
    // Spawn from random positions
    if(Math.random() < 0.1) {
      let rx = Math.random() * c.width;
      let ry = Math.random() * c.height;
      spawnEffects(rx, ry, 0.5);
    }
    
    // Screen flash
    ctx.fillStyle = `rgba(255, 255, 255, ${(intensity - 0.9) * 0.1})`;
    ctx.fillRect(0, 0, c.width, c.height);
  }
  
  // Update and draw all effects
  waves = waves.filter(w => {
    let keep = w.update();
    w.draw();
    return keep;
  });
  
  smokePaths = smokePaths.filter(s => {
    let keep = s.update();
    s.draw();
    return keep;
  });
  
  tendrils = tendrils.filter(t => {
    let keep = t.update();
    t.draw();
    return keep;
  });
  
  particles = particles.filter(p => {
    let keep = p.update();
    p.draw();
    return keep;
  });
  
  // Draw connection lines to cursor when pressed
  if(isPressed) {
    ctx.strokeStyle = `hsla(${280 + Math.sin(time) * 80}, 80%, 60%, ${0.3 + intensity * 0.4})`;
    ctx.lineWidth = 1 + intensity * 3;
    ctx.shadowBlur = 15;
    ctx.shadowColor = `hsla(${280}, 100%, 50%, ${intensity})`;
    
    // Draw to nearby particles
    particles.slice(-20).forEach(p => {
      ctx.beginPath();
      ctx.moveTo(mouseX, mouseY);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    });
  }
  
  // Update UI
  document.getElementById('intensityFill').style.width = (intensity * 100) + '%';
  updateState();
  
  requestAnimationFrame(animate);
}

// Mouse events
c.addEventListener('mousemove', (e) => {
  targetX = e.clientX;
  targetY = e.clientY;
  
  const cursor = document.getElementById('cursor');
  const pulseRing = document.getElementById('pulseRing');
  
  if(cursor && pulseRing) {
      cursor.style.left = e.clientX + 'px';
      cursor.style.top = e.clientY + 'px';
      pulseRing.style.left = e.clientX + 'px';
      pulseRing.style.top = e.clientY + 'px';
  }
  
  if(isPressed) {
    spawnEffects(e.clientX, e.clientY, 0.5);
  }
});

c.addEventListener('mousedown', (e) => {
  isPressed = true;
  targetIntensity = 1;
  spawnEffects(e.clientX, e.clientY, 3);
  
  const cursor = document.getElementById('cursor');
  if(cursor) {
      cursor.style.width = '40px';
      cursor.style.height = '40px';
      cursor.style.borderColor = 'rgba(255, 0, 255, 1)';
  }
});

c.addEventListener('mouseup', () => {
  isPressed = false;
  targetIntensity = 0;
  
  const cursor = document.getElementById('cursor');
  if(cursor) {
      cursor.style.width = '30px';
      cursor.style.height = '30px';
      cursor.style.borderColor = 'rgba(255, 255, 255, 0.8)';
  }
});

// Touch events for mobile
c.addEventListener('touchstart', (e) => {
  // e.preventDefault(); // Commented out to allow standard browser gestures if needed, though often nice for games
  let touch = e.touches[0];
  targetX = touch.clientX;
  targetY = touch.clientY;
  isPressed = true;
  targetIntensity = 1;
  spawnEffects(touch.clientX, touch.clientY, 3);
  
  // Move visual cursor to touch point even if hidden by CSS
  const cursor = document.getElementById('cursor');
  const pulseRing = document.getElementById('pulseRing');
  if(cursor) {
      cursor.style.left = touch.clientX + 'px';
      cursor.style.top = touch.clientY + 'px';
  }
  if(pulseRing) {
      pulseRing.style.left = touch.clientX + 'px';
      pulseRing.style.top = touch.clientY + 'px';
  }
}, {passive: false});

c.addEventListener('touchmove', (e) => {
  // e.preventDefault();
  let touch = e.touches[0];
  targetX = touch.clientX;
  targetY = touch.clientY;
  if(isPressed) {
    spawnEffects(touch.clientX, touch.clientY, 0.5);
  }
}, {passive: false});

c.addEventListener('touchend', () => {
  isPressed = false;
  targetIntensity = 0;
});

// Spacebar for instant overflow
document.addEventListener('keydown', (e) => {
  if(e.code === 'Space') {
    // e.preventDefault(); // Prevent scrolling
    targetIntensity = 1;
    for(let i = 0; i < 50; i++) {
      spawnEffects(
        Math.random() * c.width,
        Math.random() * c.height,
        2
      );
    }
  }
});

document.addEventListener('keyup', (e) => {
  if(e.code === 'Space') {
    targetIntensity = 0;
  }
});

// Init
animate();
</script>
</body>
</html>

