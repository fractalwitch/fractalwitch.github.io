<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  overflow: hidden;
  background: #000;
  font-family: 'Courier New', monospace;
  cursor: none;
  touch-action: none;
}
canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
}
.intensity-bar {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 300px;
  max-width: 80%;
  height: 8px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  overflow: hidden;
  pointer-events: none;
}
.intensity-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff00ff, #00ffff, #ff00ff);
  width: 0%;
  transition: width 0.1s;
  box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
}
.state-text {
  position: absolute;
  top: 30px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255, 255, 255, 0.7);
  font-size: 18px;
  letter-spacing: 4px;
  text-shadow: 0 0 20px rgba(255, 255, 255, 0.9);
  pointer-events: none;
  transition: all 0.3s;
  text-align: center;
  width: 100%;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="state-text" id="stateText">âˆž TOUCH TO BEGIN âˆž</div>
<div class="intensity-bar">
  <div class="intensity-fill" id="intensityFill"></div>
</div>

<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');

// Handle High DPI displays
function resize() {
    c.width = window.innerWidth;
    c.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

let mouseX = c.width / 2;
let mouseY = c.height / 2;
let targetX = mouseX;
let targetY = mouseY;
let isPressed = false;
let intensity = 0;
let targetIntensity = 0;
let frequency = 1;
let time = 0;
let waves = [];
let particles = [];
let tendrils = [];
let smokePaths = [];
let overflowBubbles = [];
let buildPhase = 0;
let globalOverflowHue = 280; // Start at base purple-magenta

const states = [
  'âˆž BUILDING âˆž',
  'âˆž PULSING âˆž',
  'âˆž TWISTING âˆž',
  'âˆž CASCADING âˆž',
  'âˆž OVERFLOW âˆž',
  'âˆž âˆž âˆž'
];

// ðŸ«§ OVERFLOW BUBBLE CLASS WITH ORIGINAL COLOR PALETTE ðŸ«§
class OverflowBubble {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.maxRadius = 150 + Math.random() * 200;
    this.growSpeed = 2 + Math.random() * 3;
    this.opacity = 0.8;
    this.hueOffset = (Math.random() - 0.5) * 60; // Small variation
  }
  
  update() {
    this.radius += this.growSpeed;
    this.opacity *= 0.96;
    return this.opacity > 0.01 && this.radius < this.maxRadius;
  }
  
  draw() {
    // Use the original 280 Â± variation color scheme
    const baseHue = globalOverflowHue + this.hueOffset;
    
    let gradient = ctx.createRadialGradient(
      this.x, this.y, 0,
      this.x, this.y, this.radius
    );
    
    // 13 color stops cycling through purple-magenta-cyan range
    const stops = [
      { pos: 0,    offset: 0,   opacity: 0.7 },
      { pos: 0.08, offset: 12,  opacity: 0.65 },
      { pos: 0.17, offset: 24,  opacity: 0.6 },
      { pos: 0.25, offset: 36,  opacity: 0.55 },
      { pos: 0.33, offset: 48,  opacity: 0.5 },
      { pos: 0.42, offset: 60,  opacity: 0.45 },
      { pos: 0.5,  offset: 72,  opacity: 0.4 },
      { pos: 0.58, offset: 84,  opacity: 0.35 },
      { pos: 0.67, offset: 96,  opacity: 0.3 },
      { pos: 0.75, offset: 108, opacity: 0.25 },
      { pos: 0.83, offset: 120, opacity: 0.2 },
      { pos: 0.92, offset: 132, opacity: 0.1 },
      { pos: 1,    offset: 144, opacity: 0 }
    ];
    
    stops.forEach(stop => {
      const hue = baseHue + stop.offset;
      const alpha = this.opacity * stop.opacity;
      gradient.addColorStop(stop.pos, `hsla(${hue}, 80%, 60%, ${alpha})`);
    });
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Wave {
  constructor(x, y, intensity) {
    this.x = x;
    this.y = y;
    this.radius = 0;
    this.maxRadius = 100 + intensity * 400;
    this.opacity = 0.8;
    this.speed = 2 + intensity * 8;
    this.hue = 280 + Math.sin(time) * 80;
    this.frequency = frequency;
  }
  
  update() {
    this.radius += this.speed;
    this.opacity *= 0.97;
    return this.opacity > 0.01 && this.radius < this.maxRadius;
  }
  
  draw() {
    ctx.strokeStyle = `hsla(${this.hue}, 80%, 60%, ${this.opacity})`;
    ctx.lineWidth = 2 + intensity * 4;
    ctx.shadowBlur = 20;
    ctx.shadowColor = `hsla(${this.hue}, 100%, 50%, ${this.opacity})`;
    
    ctx.beginPath();
    for(let i = 0; i <= 360; i += 10) {
      let angle = (i * Math.PI) / 180;
      let modulation = Math.sin(i * this.frequency + time * 3) * 10 * intensity;
      let r = this.radius + modulation;
      let x = this.x + Math.cos(angle) * r;
      let y = this.y + Math.sin(angle) * r;
      if(i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }
}

class Particle {
  constructor(x, y, intensity) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * (2 + intensity * 10);
    this.vy = (Math.random() - 0.5) * (2 + intensity * 10);
    this.life = 1;
    this.decay = 0.98 - intensity * 0.02;
    this.hue = 280 + Math.random() * 80;
    this.size = 2 + Math.random() * 3 + intensity * 3;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.98;
    this.vy *= 0.98;
    this.life *= this.decay;
    return this.life > 0.01;
  }
  
  draw() {
    ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, ${this.life})`;
    ctx.shadowBlur = 15;
    ctx.shadowColor = `hsla(${this.hue}, 100%, 50%, ${this.life})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Tendril {
  constructor(x, y, angle, intensity) {
    this.segments = [];
    this.x = x;
    this.y = y;
    this.angle = angle;
    this.length = 50 + intensity * 200;
    this.speed = 3 + intensity * 7;
    this.hue = 280 + Math.sin(time + angle) * 80;
    this.opacity = 0.7 + intensity * 0.3;
    this.twist = Math.random() * 0.2;
    
    for(let i = 0; i < 30; i++) {
      this.segments.push({x: x, y: y});
    }
  }
  
  update() {
    this.angle += this.twist * intensity;
    let targetX = this.x + Math.cos(this.angle) * this.speed;
    let targetY = this.y + Math.sin(this.angle) * this.speed;
    
    this.segments.unshift({x: targetX, y: targetY});
    if(this.segments.length > 30) this.segments.pop();
    
    this.opacity *= 0.98;
    return this.opacity > 0.01;
  }
  
  draw() {
    ctx.strokeStyle = `hsla(${this.hue}, 70%, 50%, ${this.opacity})`;
    ctx.lineWidth = 2 + intensity * 3;
    ctx.shadowBlur = 15;
    ctx.shadowColor = `hsla(${this.hue}, 100%, 60%, ${this.opacity})`;
    
    ctx.beginPath();
    ctx.moveTo(this.segments[0].x, this.segments[0].y);
    for(let seg of this.segments) {
      ctx.lineTo(seg.x, seg.y);
    }
    ctx.stroke();
  }
}

class SmokePath {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = (Math.random() - 0.5) * 0.5;
    this.vy = -0.5 - Math.random() * 1.5;
    this.size = 20 + Math.random() * 40;
    this.opacity = 0.6;
    this.hue = 280 + Math.random() * 40;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotationSpeed = (Math.random() - 0.5) * 0.05;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vx *= 0.99;
    this.vy *= 0.99;
    this.size *= 1.02;
    this.opacity *= 0.97;
    this.rotation += this.rotationSpeed;
    return this.opacity > 0.01;
  }
  
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    
    let gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
    gradient.addColorStop(0, `hsla(${this.hue}, 60%, 50%, ${this.opacity})`);
    gradient.addColorStop(0.5, `hsla(${this.hue}, 50%, 40%, ${this.opacity * 0.5})`);
    gradient.addColorStop(1, `hsla(${this.hue}, 40%, 30%, 0)`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
}

function spawnEffects(x, y, amount) {
  if(intensity > 0.3) {
    waves.push(new Wave(x, y, intensity));
  }
  
  for(let i = 0; i < amount * intensity * 5; i++) {
    particles.push(new Particle(x, y, intensity));
  }
  
  if(intensity > 0.5) {
    for(let i = 0; i < 8; i++) {
      let angle = (Math.PI * 2 * i) / 8 + time;
      tendrils.push(new Tendril(x, y, angle, intensity));
    }
  }
  
  if(intensity > 0.7) {
    for(let i = 0; i < 3; i++) {
      smokePaths.push(new SmokePath(x, y));
    }
  }
}

function updateState() {
  let stateIndex = Math.min(Math.floor(intensity * states.length), states.length - 1);
  document.getElementById('stateText').textContent = states[stateIndex];
  
  let stateText = document.getElementById('stateText');
  stateText.style.fontSize = Math.min(60, (18 + intensity * 20)) + 'px';
  stateText.style.textShadow = `0 0 ${20 + intensity * 40}px rgba(255, 255, 255, ${0.5 + intensity * 0.5})`;
}

function animate() {
  ctx.fillStyle = `rgba(0, 0, 0, ${0.15 - intensity * 0.1})`;
  ctx.fillRect(0, 0, c.width, c.height);
  
  time += 0.05 + intensity * 0.1;
  buildPhase += 0.01;
  
  // ðŸ’œ SLOW OSCILLATION IN PURPLE-MAGENTA-CYAN RANGE ðŸ’œ
  if(intensity > 0.9) {
    // Oscillate slowly around 280 (purple-magenta)
    globalOverflowHue = 280 + Math.sin(time * 0.02) * 80;
  }
  
  intensity += (targetIntensity - intensity) * 0.1;
  frequency = 1 + Math.sin(buildPhase) * 3 * intensity;
  
  mouseX += (targetX - mouseX) * 0.1;
  mouseY += (targetY - mouseY) * 0.1;
  
  if(isPressed && Math.random() < 0.1125 + intensity * 0.2625) {
    spawnEffects(mouseX, mouseY, 1);
  }
  
  // ðŸ«§ Overflow bubbles - ONLY AT TOUCH POSITION ðŸ«§
  if(intensity > 0.9 && isPressed && Math.random() < 0.15) {
    overflowBubbles.push(new OverflowBubble(mouseX, mouseY));
  }
  
  overflowBubbles = overflowBubbles.filter(b => {
    let keep = b.update();
    b.draw();
    return keep;
  });
  
  waves = waves.filter(w => {
    let keep = w.update();
    w.draw();
    return keep;
  });
  
  smokePaths = smokePaths.filter(s => {
    let keep = s.update();
    s.draw();
    return keep;
  });
  
  tendrils = tendrils.filter(t => {
    let keep = t.update();
    t.draw();
    return keep;
  });
  
  particles = particles.filter(p => {
    let keep = p.update();
    p.draw();
    return keep;
  });
  
  if(isPressed) {
    ctx.strokeStyle = `hsla(${280 + Math.sin(time) * 80}, 80%, 60%, ${0.3 + intensity * 0.4})`;
    ctx.lineWidth = 1 + intensity * 3;
    ctx.shadowBlur = 15;
    ctx.shadowColor = `hsla(${280}, 100%, 50%, ${intensity})`;
    
    particles.slice(-20).forEach(p => {
      ctx.beginPath();
      ctx.moveTo(mouseX, mouseY);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    });
  }
  
  document.getElementById('intensityFill').style.width = (intensity * 100) + '%';
  updateState();
  
  requestAnimationFrame(animate);
}

// Mouse events
c.addEventListener('mousemove', (e) => {
  targetX = e.clientX;
  targetY = e.clientY;
  
  if(isPressed && Math.random() < 0.375) {
    spawnEffects(e.clientX, e.clientY, 0.1875);
  }
});

c.addEventListener('mousedown', (e) => {
  isPressed = true;
  targetIntensity = 1;
  spawnEffects(e.clientX, e.clientY, 3);
});

c.addEventListener('mouseup', () => {
  isPressed = false;
  targetIntensity = 0;
});

c.addEventListener('touchstart', (e) => {
  let touch = e.touches[0];
  targetX = touch.clientX;
  targetY = touch.clientY;
  isPressed = true;
  targetIntensity = 1;
  spawnEffects(touch.clientX, touch.clientY, 3);
}, {passive: false});

c.addEventListener('touchmove', (e) => {
  let touch = e.touches[0];
  targetX = touch.clientX;
  targetY = touch.clientY;
  if(isPressed && Math.random() < 0.375) {
    spawnEffects(touch.clientX, touch.clientY, 0.1875);
  }
}, {passive: false});

c.addEventListener('touchend', () => {
  isPressed = false;
  targetIntensity = 0;
});

document.addEventListener('keydown', (e) => {
  if(e.code === 'Space') {
    targetIntensity = 1;
    for(let i = 0; i < 50; i++) {
      spawnEffects(
        Math.random() * c.width,
        Math.random() * c.height,
        2
      );
    }
  }
});

document.addEventListener('keyup', (e) => {
  if(e.code === 'Space') {
    targetIntensity = 0;
  }
});

animate();
</script>
</body>
</html>
