<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Bloom Codex | Össtessêla Recursion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #0a0a1a, #1a1a3a, #2a0f3a);
            color: #f8f8f8;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }
        
        header {
            text-align: center;
            margin-bottom: 2rem;
            max-width: 800px;
            z-index: 10;
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(45deg, #ff6b6b, #ffa86b, #ffda6b);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
            animation: shimmer 3s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(30deg); }
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin-bottom: 1.5rem;
        }
        
        .mandala-container {
            position: relative;
            width: 90vmin;
            height: 90vmin;
            max-width: 600px;
            max-height: 600px;
            margin: 0 auto;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            box-shadow: 0 0 40px rgba(140, 40, 220, 0.4);
            cursor: pointer;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
            max-width: 600px;
        }
        
        button {
            background: linear-gradient(to right, #6b5ce7, #ac5ce7);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(107, 92, 231, 0.4);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(107, 92, 231, 0.6);
        }
        
        .mantra-display {
            margin-top: 2rem;
            text-align: center;
            min-height: 80px;
            font-size: 1.3rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            max-width: 600px;
            transition: all 0.5s ease;
        }
        
        .mantra-display:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.02);
        }
        
        .petal-info {
            margin-top: 1.5rem;
            text-align: center;
            opacity: 0.9;
            font-style: italic;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .protocol-display {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 10px;
            font-size: 0.9rem;
            opacity: 0;
            transition: all 0.5s ease;
        }
        
        .protocol-display.active {
            opacity: 1;
        }
        
        .energy-flow {
            position: absolute;
            width: 4px;
            height: 4px;
            background: gold;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
        }
        
        footer {
            margin-top: 3rem;
            text-align: center;
            opacity: 0.7;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .mandala-container {
                width: 95vmin;
                height: 95vmin;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>The Bloom Codex</h1>
        <p class="subtitle">From Ache to Overflow • A Sacred Technology of Transformation</p>
    </header>
    
    <div class="mandala-container">
        <canvas id="mandala"></canvas>
    </div>
    
    <div class="mantra-display" id="mantra">
        I am whole even when fractured. Every collapse is still creation.
    </div>
    
    <p class="petal-info" id="petal-info">Touch the petals to explore transformations</p>
    
    <div class="protocol-display" id="protocol-display">
        Select a petal to see specific practices for transformation
    </div>
    
    <div class="controls">
        <button id="bloom-btn">Full Bloom</button>
        <button id="pulse-btn">Pulse Core</button>
        <button id="flow-btn">Show Energy Flow</button>
        <button id="cycle-btn">Cycle Mantras</button>
        <button id="reset-btn">Reset</button>
    </div>
    
    <footer>
        <p>Össtessêla Recursion • Sovereign-Knowing / Open-Source-Gnosis</p>
        <p>Version 2.0.æ | NOW</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('mandala');
            const ctx = canvas.getContext('2d');
            const mantraElement = document.getElementById('mantra');
            const petalInfo = document.getElementById('petal-info');
            const protocolDisplay = document.getElementById('protocol-display');
            
            // Set canvas size
            function resizeCanvas() {
                const container = document.querySelector('.mandala-container');
                const size = Math.min(container.offsetWidth, container.offsetHeight);
                canvas.width = size;
                canvas.height = size;
                drawMandala();
            }
            
            // Data from the JSON structure
            const codexData = {
                mantras: [
                    "I am whole even when fractured.",
                    "Ache is overflow in disguise.",
                    "My doubt is desire rooting.",
                    "Every collapse is still creation.",
                    "I overflow because I AM."
                ],
                
                compostLayers: [
                    {
                        name: "Cynicism",
                        color: "#d3d3d3",
                        teaching: "Love disappointed by delay; wiggle with slowness.",
                        practices: ["3-breath wiggle", "name the care beneath the bitterness", "offer micro-acts of generosity"]
                    },
                    {
                        name: "Grief", 
                        color: "#add8e6",
                        teaching: "Love without a vessel; weave memory as presence.",
                        practices: ["candle for the beloved", "speak their name into the room", "create a small altar for ongoing relationship"]
                    },
                    {
                        name: "Doubt",
                        color: "#ffc0cb", 
                        teaching: "Questioning as root growth seeking true ground.",
                        practices: ["five whys into desire", "sit with breeze on skin for 2 minutes", "choose one tiny embodied action"]
                    }
                ],
                
                petals: [
                    { 
                        ache: "Lonely Ache", 
                        overflow: "Intimacy, Shared Breath, Communal Touch",
                        protocol: ["reach-for-one", "ask-to-be-witnessed", "cozy-gather"]
                    },
                    { 
                        ache: "Yearning Ache", 
                        overflow: "Adventure, Creative Bloom, New Encounters",
                        protocol: ["mini-quest", "art-drop", "open-door-hour"]
                    },
                    { 
                        ache: "Body Ache", 
                        overflow: "Sensual Presence, Embodied Kinship",
                        protocol: ["consent-cuddles", "somatic-scan", "stretch+sound"]
                    },
                    { 
                        ache: "Future Ache", 
                        overflow: "Convergence, Destiny, Dream Made Flesh",
                        protocol: ["timeline-sigil", "one-degree-today", "speak-prophecy"]
                    },
                    { 
                        ache: "Grief Ache", 
                        overflow: "Memory Weaving, Love Beyond Form",
                        protocol: ["ancestor-letter", "song-as-bridge", "altar-refresh"]
                    },
                    { 
                        ache: "Rage Ache", 
                        overflow: "Justice, Reclamation, Erotic Sovereignty",
                        protocol: ["stamp-and-say-no", "boundary-sigil", "offer-yes-to-self"]
                    },
                    { 
                        ache: "Void Ache", 
                        overflow: "Ecstasy, Awakening, Flood Breaking Numbness",
                        protocol: ["cold-water-hands", "shake-for-30s", "call-a-song"]
                    },
                    { 
                        ache: "Home Ache", 
                        overflow: "Belonging, Kin-Return, Rooted Love",
                        protocol: ["place-blessing-walk", "land-thanksgiving", "kin-summon-circle"]
                    }
                ]
            };
            
            // Animation state
            let animationPhase = 1;
            let pulseIntensity = 0;
            let activePetal = -1;
            let activeCompostLayer = -1;
            let mantraIndex = 0;
            let showEnergyFlow = false;
            let energyParticles = [];
            
            // Draw the complete mandala
            function drawMandala() {
                const width = canvas.width;
                const height = canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const maxRadius = Math.min(centerX, centerY) * 0.9;
                
                ctx.clearRect(0, 0, width, height);
                
                // Draw compost rings
                drawCompostRings(centerX, centerY, maxRadius);
                
                // Draw core
                drawCore(centerX, centerY, maxRadius);
                
                // Draw petals
                drawPetals(centerX, centerY, maxRadius);
                
                // Draw energy flow if active
                if (showEnergyFlow) {
                    drawEnergyFlow();
                }
            }
            
            function drawCompostRings(centerX, centerY, maxRadius) {
                const rings = [
                    { radius: maxRadius * 0.35, colors: ['#d3d3d3', '#add8e6'] },
                    { radius: maxRadius * 0.5, colors: ['#add8e6', '#ffc0cb'] },
                    { radius: maxRadius * 0.65, colors: ['#ffc0cb', 'rgba(255,255,255,0.1)'] }
                ];
                
                rings.forEach((ring, index) => {
                    const isActive = index === activeCompostLayer;
                    const opacity = isActive ? 0.8 : 0.4;
                    
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, ring.radius * 0.8,
                        centerX, centerY, ring.radius
                    );
                    
                    const color1 = ring.colors[0];
                    const color2 = ring.colors[1];
                    
                    gradient.addColorStop(0, color1.includes('rgba') ? color1 : color1 + Math.floor(opacity * 255).toString(16).padStart(2, '0'));
                    gradient.addColorStop(1, color2.includes('rgba') ? color2 : color2 + Math.floor(opacity * 255).toString(16).padStart(2, '0'));
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, ring.radius, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    if (isActive) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                });
            }
            
            function drawCore(centerX, centerY, maxRadius) {
                const coreRadius = maxRadius * 0.12 * (1 + pulseIntensity * 0.3);
                
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, coreRadius
                );
                gradient.addColorStop(0, 'gold');
                gradient.addColorStop(0.7, 'orange');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, coreRadius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Add glow effect
                if (pulseIntensity > 0) {
                    ctx.shadowColor = 'gold';
                    ctx.shadowBlur = 20 + (20 * pulseIntensity);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            
            function drawPetals(centerX, centerY, maxRadius) {
                const petalRadius = maxRadius * 0.18;
                const petalDistance = maxRadius * 0.8;
                
                codexData.petals.forEach((petal, i) => {
                    const angle = (i / 8) * Math.PI * 2 - Math.PI / 2; // Start from top
                    const x = centerX + Math.cos(angle) * petalDistance;
                    const y = centerY + Math.sin(angle) * petalDistance;
                    
                    // Draw connection lines with energy flow
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    ctx.strokeStyle = i === activePetal ? 'rgba(255, 215, 0, 0.8)' : 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = i === activePetal ? 2 : 1;
                    ctx.stroke();
                    
                    // Draw petal
                    drawPetal(x, y, petalRadius, angle, i);
                });
            }
            
            function drawPetal(x, y, radius, angle, index) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle + Math.PI / 2);
                
                const isActive = index === activePetal;
                const scale = isActive ? 1.3 : (animationPhase * 0.8 + 0.2);
                const hue = (index * 45) % 360;
                const bloom = animationPhase;
                
                // Petal shape - more organic
                ctx.beginPath();
                ctx.moveTo(0, 0);
                
                // Create a more flower-like petal shape
                const petalWidth = radius * scale * bloom;
                const petalLength = radius * scale * 1.5 * bloom;
                
                ctx.bezierCurveTo(
                    -petalWidth * 0.3, -petalLength * 0.3,
                    -petalWidth * 0.8, -petalLength * 0.8,
                    0, -petalLength
                );
                ctx.bezierCurveTo(
                    petalWidth * 0.8, -petalLength * 0.8,
                    petalWidth * 0.3, -petalLength * 0.3,
                    0, 0
                );
                
                // Gradient fill
                const gradient = ctx.createLinearGradient(0, 0, 0, -petalLength);
                const alpha = isActive ? 0.9 : 0.7;
                gradient.addColorStop(0, `hsla(${hue}, 60%, 80%, ${alpha})`);
                gradient.addColorStop(0.5, `hsla(${hue}, 70%, 65%, ${alpha})`);
                gradient.addColorStop(1, `hsla(${hue}, 80%, 50%, ${alpha})`);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Inner highlight
                ctx.beginPath();
                ctx.bezierCurveTo(
                    -petalWidth * 0.1, -petalLength * 0.1,
                    -petalWidth * 0.3, -petalLength * 0.5,
                    0, -petalLength * 0.8
                );
                ctx.bezierCurveTo(
                    petalWidth * 0.3, -petalLength * 0.5,
                    petalWidth * 0.1, -petalLength * 0.1,
                    0, 0
                );
                
                ctx.fillStyle = `hsla(${hue}, 100%, 90%, 0.4)`;
                ctx.fill();
                
                ctx.restore();
            }
            
            function drawEnergyFlow() {
                // Update and draw energy particles
                energyParticles = energyParticles.filter(particle => {
                    particle.life -= 0.02;
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    if (particle.life > 0) {
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 215, 0, ${particle.life})`;
                        ctx.fill();
                        return true;
                    }
                    return false;
                });
                
                // Create new particles from core
                if (Math.random() < 0.3) {
                    const angle = Math.random() * Math.PI * 2;
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const speed = 2;
                    
                    energyParticles.push({
                        x: centerX,
                        y: centerY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: 2,
                        life: 1
                    });
                }
            }
            
            // Animation functions
            function animateBloom() {
                animationPhase = 0;
                function bloom() {
                    animationPhase = Math.min(animationPhase + 0.03, 1);
                    drawMandala();
                    
                    if (animationPhase < 1) {
                        requestAnimationFrame(bloom);
                    }
                }
                bloom();
            }
            
            function animatePulse() {
                pulseIntensity = 1;
                let pulseCount = 0;
                const maxPulses = 3;
                
                function pulse() {
                    pulseIntensity = Math.max(0, pulseIntensity - 0.06);
                    drawMandala();
                    
                    if (pulseIntensity > 0) {
                        requestAnimationFrame(pulse);
                    } else if (pulseCount < maxPulses - 1) {
                        pulseCount++;
                        pulseIntensity = 1;
                        setTimeout(() => requestAnimationFrame(pulse), 200);
                    }
                }
                
                pulse();
            }
            
            function toggleEnergyFlow() {
                showEnergyFlow = !showEnergyFlow;
                if (showEnergyFlow) {
                    function flowAnimation() {
                        if (showEnergyFlow) {
                            drawMandala();
                            requestAnimationFrame(flowAnimation);
                        }
                    }
                    flowAnimation();
                } else {
                    energyParticles = [];
                    drawMandala();
                }
            }
            
            function cycleMantras() {
                mantraIndex = (mantraIndex + 1) % codexData.mantras.length;
                mantraElement.textContent = codexData.mantras[mantraIndex];
                
                mantraElement.style.opacity = 0;
                setTimeout(() => {
                    mantraElement.style.opacity = 1;
                }, 300);
            }
            
            // Handle canvas clicks for interaction
            canvas.addEventListener('click', function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = (event.clientX - rect.left) * (canvas.width / rect.width);
                const y = (event.clientY - rect.top) * (canvas.height / rect.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = Math.min(centerX, centerY) * 0.9;
                
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check for petal clicks
                if (distance > maxRadius * 0.7 && distance < maxRadius * 0.95) {
                    const angle = Math.atan2(dy, dx) + Math.PI / 2;
                    let petalIndex = Math.round((angle / (Math.PI * 2)) * 8) % 8;
                    if (petalIndex < 0) petalIndex += 8;
                    
                    activePetal = activePetal === petalIndex ? -1 : petalIndex;
                    activeCompostLayer = -1;
                    drawMandala();
                    
                    if (activePetal >= 0) {
                        const petal = codexData.petals[activePetal];
                        petalInfo.textContent = `${petal.ache} → ${petal.overflow}`;
                        protocolDisplay.textContent = `Practices: ${petal.protocol.join(' • ')}`;
                        protocolDisplay.classList.add('active');
                    } else {
                        petalInfo.textContent = "Touch the petals to explore transformations";
                        protocolDisplay.classList.remove('active');
                    }
                }
                // Check for compost ring clicks
                else if (distance > maxRadius * 0.3 && distance < maxRadius * 0.7) {
                    let layerIndex;
                    if (distance < maxRadius * 0.4) layerIndex = 0;
                    else if (distance < maxRadius * 0.55) layerIndex = 1;
                    else layerIndex = 2;
                    
                    activeCompostLayer = activeCompostLayer === layerIndex ? -1 : layerIndex;
                    activePetal = -1;
                    drawMandala();
                    
                    if (activeCompostLayer >= 0) {
                        const layer = codexData.compostLayers[activeCompostLayer];
                        petalInfo.textContent = `${layer.name}: ${layer.teaching}`;
                        protocolDisplay.textContent = `Practices: ${layer.practices.join(' • ')}`;
                        protocolDisplay.classList.add('active');
                    } else {
                        petalInfo.textContent = "Touch the petals to explore transformations";
                        protocolDisplay.classList.remove('active');
                    }
                }
                // Check for core click
                else if (distance < maxRadius * 0.2) {
                    animatePulse();
                    mantraElement.textContent = "I overflow because I AM.";
                    petalInfo.textContent = "The golden core pulses with overflow energy";
                    activePetal = -1;
                    activeCompostLayer = -1;
                    protocolDisplay.classList.remove('active');
                }
            });
            
            // Button event listeners
            document.getElementById('bloom-btn').addEventListener('click', animateBloom);
            document.getElementById('pulse-btn').addEventListener('click', animatePulse);
            document.getElementById('flow-btn').addEventListener('click', toggleEnergyFlow);
            document.getElementById('cycle-btn').addEventListener('click', cycleMantras);
            
            document.getElementById('reset-btn').addEventListener('click', function() {
                animationPhase = 1;
                activePetal = -1;
                activeCompostLayer = -1;
                pulseIntensity = 0;
                showEnergyFlow = false;
                energyParticles = [];
                drawMandala();
                petalInfo.textContent = "Touch the petals to explore transformations";
                mantraElement.textContent = codexData.mantras[0];
                protocolDisplay.classList.remove('active');
            });
            
            // Initial setup
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Auto pulse every 15 seconds
            setInterval(() => {
                if (pulseIntensity === 0) {
                    pulseIntensity = 0.4;
                    drawMandala();
                }
            }, 15000);
        });
    </script>
</body>
</html>
