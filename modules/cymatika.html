<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ΣΩ | V9.0 RESURRECTION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&family=Cinzel:wght@400;700&display=swap');

        :root {
            --c-void: #02000a;
            --c-magenta: #ff00ff;
            --c-cyan: #00ffff;
            --c-acid: #ccff00;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--c-void);
            font-family: 'Courier Prime', monospace;
            color: #ffffff;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        #intro-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(2, 0, 10, 0.95);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.3s;
        }

        .vanish { opacity: 0 !important; pointer-events: none !important; }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 12vw;
            color: #fff;
            text-shadow: 0 0 20px var(--c-magenta);
            margin-bottom: 40px;
            text-align: center;
        }

        .start-btn {
            background: transparent;
            border: 2px solid var(--c-cyan);
            color: var(--c-cyan);
            padding: 20px 40px;
            font-size: 1.2rem;
            font-family: 'Courier Prime';
            letter-spacing: 2px;
            text-transform: uppercase;
            box-shadow: 0 0 20px var(--c-cyan);
        }

        .start-btn:active { background: var(--c-cyan); color: #000; }

        .toolbar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            z-index: 100;
            width: 95%;
            pointer-events: auto;
        }

        .show-toolbar { display: flex !important; }

        .mod-key {
            flex: 1;
            height: 80px;
            background: rgba(20, 20, 20, 0.6);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }

        .mod-key span { font-size: 1rem; font-weight: bold; display: block; margin-bottom: 4px; }
        .key-echo { border-top: 3px solid var(--c-cyan); color: var(--c-cyan); }
        .key-glitch { border-top: 3px solid var(--c-magenta); color: var(--c-magenta); }
        .key-shimmer { border-top: 3px solid var(--c-acid); color: var(--c-acid); }

        .mod-key.pressed {
            background: currentColor;
            color: #000 !important;
            box-shadow: 0 0 30px currentColor;
        }

    </style>
</head>
<body>

    <canvas id="glcanvas"></canvas>

    <div id="intro-screen">
        <h1>RESURRECTION<br>V9.0</h1>
        <button class="start-btn" onclick="activate()">ACTIVATE</button>
    </div>

    <div class="toolbar" id="toolbar">
        <div class="mod-key key-echo" ontouchstart="toggleFX('echo', true)" ontouchend="toggleFX('echo', false)" onmousedown="toggleFX('echo', true)" onmouseup="toggleFX('echo', false)">
            <span>ECHO</span>DELAY
        </div>
        <div class="mod-key key-glitch" ontouchstart="toggleFX('glitch', true)" ontouchend="toggleFX('glitch', false)" onmousedown="toggleFX('glitch', true)" onmouseup="toggleFX('glitch', false)">
            <span>GLITCH</span>TIME
        </div>
        <div class="mod-key key-shimmer" ontouchstart="toggleFX('shimmer', true)" ontouchend="toggleFX('shimmer', false)" onmousedown="toggleFX('shimmer', true)" onmouseup="toggleFX('shimmer', false)">
            <span>SHIMMER</span>RIP
        </div>
    </div>

    <script>
        // --- 1. ACTIVATION ---
        function activate() {
            document.getElementById('intro-screen').classList.add('vanish');
            document.getElementById('toolbar').classList.add('show-toolbar');
            
            // SUPER SPLASH (High Intensity for Byte Mode)
            for(let i=0; i<30; i++) {
                splats.push({
                    x: Math.random(), y: Math.random(), 
                    dx: (Math.random()-0.5)*2000, 
                    dy: (Math.random()-0.5)*2000, 
                    c: [10, 0, 20] // OVERDRIVE COLORS
                });
            }
            initAudio();
        }

        // --- 2. AUDIO ENGINE (THE TEAR V2) ---
        let actx, mainOut, osc, gain, delay, fback;
        let noise, noiseGain, chopperLFO, chopperAmp;
        let isAudio = false;

        function initAudio() {
            if(isAudio) return;
            try {
                const AC = window.AudioContext || window.webkitAudioContext;
                actx = new AC();
                actx.resume();

                mainOut = actx.createGain();
                mainOut.gain.value = 0.5;
                mainOut.connect(actx.destination);

                // DRONE (Sawtooth for texture)
                osc = actx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = 55;
                
                let droneLFO = actx.createOscillator();
                droneLFO.frequency.value = 0.1;
                let droneAmp = actx.createGain();
                droneAmp.gain.value = 5;
                droneLFO.connect(droneAmp).connect(osc.frequency);

                gain = actx.createGain();
                gain.gain.value = 0.3;
                
                // Filter the drone so it's deep, not buzzy
                let dFilter = actx.createBiquadFilter();
                dFilter.type = 'lowpass';
                dFilter.frequency.value = 100;

                osc.connect(dFilter).connect(gain).connect(mainOut);
                
                // ECHO
                delay = actx.createDelay();
                delay.delayTime.value = 0.33;
                fback = actx.createGain();
                fback.gain.value = 0;

                gain.connect(delay);
                delay.connect(fback);
                fback.connect(delay);
                delay.connect(mainOut);

                // --- THE RIPPER (NOISE + CHOPPER) ---
                // Simple noise buffer (Robust)
                let bSize = actx.sampleRate * 2;
                let b = actx.createBuffer(1, bSize, actx.sampleRate);
                let d = b.getChannelData(0);
                for(let i=0; i<bSize; i++) d[i] = Math.random() * 2 - 1;

                noise = actx.createBufferSource();
                noise.buffer = b;
                noise.loop = true;
                
                noiseGain = actx.createGain();
                noiseGain.gain.value = 0;

                // CHOPPER (Sawtooth LFO modulating Volume)
                chopperLFO = actx.createOscillator();
                chopperLFO.type = 'sawtooth'; 
                chopperLFO.frequency.value = 40; // 40Hz Rip
                
                chopperAmp = actx.createGain();
                chopperAmp.gain.value = 0; // Off by default

                // Route: LFO -> Gain.gain -> Noise Gain
                // Note: We use a separate gain for the LFO depth
                chopperLFO.connect(chopperAmp).connect(noiseGain.gain);

                noise.connect(noiseGain).connect(mainOut);

                osc.start();
                droneLFO.start();
                noise.start();
                chopperLFO.start();
                
                isAudio = true;
            } catch(e) { console.log(e); }
        }

        // --- 3. FX LOGIC ---
        let fx = { echo: false, glitch: false, shimmer: false };

        function toggleFX(type, on) {
            const btn = document.querySelector(`.key-${type}`);
            if(on) btn.classList.add('pressed');
            else btn.classList.remove('pressed');
            fx[type] = on;

            if(isAudio && actx) {
                // FORCE RESUME ON TOUCH
                if(actx.state === 'suspended') actx.resume();

                let t = actx.currentTime;
                
                if(type === 'echo') fback.gain.setTargetAtTime(on ? 0.9 : 0, t, 0.1);
                
                if(type === 'shimmer') {
                    // Activate the Noise volume
                    noiseGain.gain.setTargetAtTime(on ? 0.3 : 0, t, 0.05);
                    // Activate the Chopper depth (Rip effect)
                    chopperAmp.gain.setTargetAtTime(on ? 1 : 0, t, 0.05);
                    
                    // Pitch shift drone
                    osc.frequency.setTargetAtTime(on ? 82.4 : 55, t, 0.1);
                }
            }
        }

        // --- 4. FLUID ENGINE (OVERDRIVE MODE) ---
        const canvas = document.getElementById('glcanvas');
        let gl = canvas.getContext('webgl');
        
        let texType;
        let ext = gl.getExtension('OES_texture_half_float');
        
        if(ext) {
            texType = ext.HALF_FLOAT_OES;
        } else {
            texType = gl.UNSIGNED_BYTE;
        }

        const vShader = `attribute vec2 p; varying vec2 uv; void main(){ uv=p*0.5+0.5; gl_Position=vec4(p,0,1); }`;
        const fSplat = `precision mediump float; varying vec2 uv; uniform sampler2D uT; uniform vec3 c; uniform vec2 p; void main(){ vec2 d=uv-p; d.x*=0.5; gl_FragColor=vec4(texture2D(uT,uv).xyz+exp(-dot(d,d)/0.005)*c,1); }`;
        const fAdv = `precision mediump float; varying vec2 uv; uniform sampler2D uV, uS; void main(){ gl_FragColor=0.95*texture2D(uS, uv - 0.02*texture2D(uV,uv).xy*vec2(0.5,1)); }`;
        
        // BOOSTED DISPLAY SHADER
        const fDisp = `precision mediump float; varying vec2 uv; uniform sampler2D uT; void main(){ 
            vec3 c=texture2D(uT,uv).rgb; 
            // OVERDRIVE THE COLORS FOR BYTE MODE
            c = c * 2.0; 
            vec3 bg = vec3(0.02, 0.0, 0.05);
            gl_FragColor=vec4(bg + c, 1); 
        }`;

        function createProg(fs) {
            let p = gl.createProgram();
            let vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, vShader); gl.compileShader(vs);
            let f = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, fs); gl.compileShader(f);
            gl.attachShader(p, vs); gl.attachShader(p, f); gl.linkProgram(p);
            return p;
        }

        let P_splat = createProg(fSplat);
        let P_adv = createProg(fAdv);
        let P_disp = createProg(fDisp);

        function createFBO() {
            let t = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, t);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 512, 0, gl.RGBA, texType, null); // Low res for speed/compat
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            return { t: t, f: gl.createFramebuffer() };
        }

        let den = [createFBO(), createFBO()];
        let vel = [createFBO(), createFBO()];
        
        let buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, -1,1, 1,1, 1,-1]), gl.STATIC_DRAW);

        function blit(p) {
            gl.useProgram(p);
            let loc = gl.getAttribLocation(p, 'p');
            gl.enableVertexAttribArray(loc);
            gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        }

        let splats = [];
        
        window.addEventListener('touchmove', e => {
            for(let i=0; i<e.touches.length; i++) {
                let t = e.touches[i];
                // OVERDRIVE INPUT
                splats.push({x: t.clientX/window.innerWidth, y: 1-t.clientY/window.innerHeight, dx:0, dy:0, c:[5,8,10]});
            }
        });
        window.addEventListener('mousemove', e => {
            if(Math.random()>0.5) splats.push({x: e.clientX/window.innerWidth, y: 1-e.clientY/window.innerHeight, dx:0, dy:0, c:[5,8,10]});
        });

        // LOOP
        let idx = 0;
        let autoPulse = 0;

        function update() {
            let next = (idx + 1) % 2;
            let cur = idx;
            autoPulse++;

            // FORCE FEED
            if(autoPulse > 60) {
                splats.push({x:0.5, y:0.5, dx:(Math.random()-0.5)*100, dy:(Math.random()-0.5)*100, c:[2,0,5]});
                autoPulse = 0;
            }

            if(fx.shimmer && Math.random()>0.5) {
               splats.push({x:Math.random(), y:Math.random(), dx:0, dy:0, c:[10,10,5]}); // BRIGHT SPARKLES
            }
            if(fx.glitch && Math.random()>0.8) {
               splats.push({x:Math.random(), y:Math.random(), dx:0, dy:0, c:[10,0,10]});
            }

            gl.viewport(0,0,256,512); 
            
            if(splats.length > 0) {
                gl.useProgram(P_splat);
                for(let s of splats) {
                    gl.uniform1i(gl.getUniformLocation(P_splat, 'uT'), 0);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, den[cur].t);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, den[next].f);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, den[next].t, 0);
                    
                    gl.uniform3f(gl.getUniformLocation(P_splat, 'c'), s.c[0], s.c[1], s.c[2]);
                    gl.uniform2f(gl.getUniformLocation(P_splat, 'p'), s.x, s.y);
                    blit(P_splat);
                    
                    let temp = cur; cur = next; next = temp;
                }
                splats = [];
            }

            gl.useProgram(P_adv);
            gl.uniform1i(gl.getUniformLocation(P_adv, 'uS'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, den[cur].t);
            
            gl.uniform1i(gl.getUniformLocation(P_adv, 'uV'), 1);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, vel[cur].t);
            
            gl.bindFramebuffer(gl.FRAMEBUFFER, den[next].f);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, den[next].t, 0);
            blit(P_adv);

            gl.viewport(0,0,canvas.width, canvas.height);
            gl.useProgram(P_disp);
            gl.uniform1i(gl.getUniformLocation(P_disp, 'uT'), 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, den[next].t);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            blit(P_disp);

            idx = next;
            requestAnimationFrame(update);
        }
        update();

    </script>
</body>
</html>
