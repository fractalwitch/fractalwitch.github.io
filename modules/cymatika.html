<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ΣΩ | V6.0 HOLOGRAPHIC CONSOLE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&family=Cinzel:wght@400;700&display=swap');

        :root {
            --c-void: #020005;
            --c-magenta: #ff00ff;
            --c-cyan: #00ffff;
            --c-acid: #ccff00;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--c-void);
            font-family: 'Courier Prime', monospace;
            color: #ffffff;
            overflow: hidden;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            mix-blend-mode: exclusion;
        }

        /* HEADER */
        h1.glitch-header {
            font-family: 'Cinzel', serif;
            font-size: 10vw;
            line-height: 0.9;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 30px var(--c-magenta);
            margin: 0;
            opacity: 0.8;
            transition: opacity 0.5s;
        }

        body.active h1.glitch-header { opacity: 0.3; }

        /* ACTIVATE BUTTON */
        .start-btn {
            pointer-events: auto;
            background: rgba(0,0,0,0.8);
            border: 2px solid var(--c-cyan);
            color: var(--c-cyan);
            padding: 1.5rem 3rem;
            font-size: 1.2rem;
            font-family: 'Courier Prime';
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            box-shadow: 0 0 20px var(--c-cyan);
            z-index: 20;
        }

        /* MODULATION TOOLBAR */
        .toolbar {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 30;
            pointer-events: auto;
            width: 90%;
            max-width: 500px;
            opacity: 0;
            transition: opacity 1s;
        }

        body.active .toolbar { opacity: 1; }

        .mod-key {
            flex: 1;
            height: 80px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-family: 'Courier Prime';
            font-size: 0.9rem;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
            transition: all 0.1s;
            touch-action: manipulation;
            user-select: none;
        }

        /* PRESSED STATES */
        .mod-key:active, .mod-key.pressed {
            transform: scale(0.95);
            box-shadow: 0 0 30px currentColor;
            background: currentColor;
            color: #000;
            border-color: #fff;
        }

        .key-echo { color: var(--c-cyan); }
        .key-glitch { color: var(--c-magenta); }
        .key-shimmer { color: var(--c-acid); }

        /* VISUALIZER OVERLAY */
        .vis-ring {
            position: absolute;
            width: 200px;
            height: 200px;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
        }
        body.active .vis-ring { opacity: 0.5; }

    </style>
</head>
<body>

    <canvas id="glcanvas"></canvas>

    <div id="ui-layer">
        <h1 class="glitch-header">HOLOGRAPHIC<br>CONSOLE</h1>
        <div id="startContainer" style="margin-top: 50px;">
            <button class="start-btn" id="startBtn">ACTIVATE CONSOLE</button>
        </div>
        
        <div class="vis-ring" id="visRing"></div>
    </div>

    <div class="toolbar">
        <div class="mod-key key-echo" id="btnEcho" data-type="echo">ECHO<br>DELAY</div>
        <div class="mod-key key-glitch" id="btnGlitch" data-type="glitch">GLITCH<br>TIME</div>
        <div class="mod-key key-shimmer" id="btnShimmer" data-type="shimmer">SHIMMER<br>NOISE</div>
    </div>

    <script>
        // --- 1. AUDIO ENGINE (MODULAR) ---
        let actx, mainOut;
        let oscDrone, oscSub, gainDrone;
        let delayNode, feedbackNode, delayGain; // Echo
        let glitchLFO, glitchGain; // Glitch
        let noiseNode, noiseGain; // Shimmer
        let analyser, dataArray;
        let isInit = false;

        async function initAudio() {
            if(isInit) return;
            const AC = window.AudioContext || window.webkitAudioContext;
            actx = new AC();
            if(actx.state === 'suspended') await actx.resume();

            mainOut = actx.createGain();
            mainOut.gain.value = 0.5;
            mainOut.connect(actx.destination);

            // ANALYSER
            analyser = actx.createAnalyser();
            analyser.fftSize = 256;
            mainOut.connect(analyser);
            dataArray = new Uint8Array(analyser.frequencyBinCount);

            // 1. DRONE (Base)
            oscDrone = actx.createOscillator();
            oscDrone.type = 'sine';
            oscDrone.frequency.value = 55; // A1
            oscSub = actx.createOscillator();
            oscSub.type = 'triangle';
            oscSub.frequency.value = 55.5; // Binaural beat

            gainDrone = actx.createGain();
            gainDrone.gain.value = 0.4;

            oscDrone.connect(gainDrone);
            oscSub.connect(gainDrone);
            gainDrone.connect(mainOut);

            // 2. ECHO LOOP (Send Effect)
            delayNode = actx.createDelay();
            delayNode.delayTime.value = 0.3; // 300ms
            feedbackNode = actx.createGain();
            feedbackNode.gain.value = 0; // Off by default
            
            // Routing: Main -> Delay -> Feedback -> Delay -> Main
            gainDrone.connect(delayNode);
            delayNode.connect(feedbackNode);
            feedbackNode.connect(delayNode);
            delayNode.connect(mainOut);

            // 3. SHIMMER (High Noise)
            const bufferSize = actx.sampleRate * 2; // 2 sec buffer
            const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            noiseNode = actx.createBufferSource();
            noiseNode.buffer = buffer;
            noiseNode.loop = true;
            const noiseFilter = actx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 2000;
            noiseGain = actx.createGain();
            noiseGain.gain.value = 0; // Off

            noiseNode.connect(noiseFilter).connect(noiseGain).connect(mainOut);

            // START ALL
            oscDrone.start();
            oscSub.start();
            noiseNode.start();

            isInit = true;
            document.body.classList.add('active');
            document.getElementById('startContainer').style.display = 'none';
        }

        // --- 2. MODULATION LOGIC ---
        const keys = document.querySelectorAll('.mod-key');
        
        // Touch Handlers for Multi-Tap
        keys.forEach(key => {
            const type = key.dataset.type;
            
            const start = (e) => {
                e.preventDefault();
                key.classList.add('pressed');
                applyEffect(type, true);
            };
            
            const end = (e) => {
                e.preventDefault();
                key.classList.remove('pressed');
                applyEffect(type, false);
            };

            key.addEventListener('mousedown', start);
            key.addEventListener('mouseup', end);
            key.addEventListener('mouseleave', end);
            key.addEventListener('touchstart', start, {passive: false});
            key.addEventListener('touchend', end, {passive: false});
        });

        function applyEffect(type, active) {
            if(!isInit) return;
            const now = actx.currentTime;

            if(type === 'echo') {
                // Ramp feedback up/down
                feedbackNode.gain.setTargetAtTime(active ? 0.8 : 0, now, 0.1);
            }
            if(type === 'glitch') {
                // Chaos FM Synthesis
                if(active) {
                    oscDrone.frequency.setValueAtTime(55, now);
                    oscDrone.frequency.linearRampToValueAtTime(110, now + 0.05); // Blip
                    // Visual glitch handled in render loop
                } else {
                    oscDrone.frequency.setTargetAtTime(55, now, 0.1);
                }
            }
            if(type === 'shimmer') {
                noiseGain.gain.setTargetAtTime(active ? 0.2 : 0, now, 0.1);
                // Pitch shift drone up for majesty
                oscSub.frequency.setTargetAtTime(active ? 110 : 55.5, now, 0.2);
            }
        }

        // --- 3. HOLOGRAPHIC FLUID ENGINE ---
        const canvas = document.getElementById('glcanvas');
        let gl = canvas.getContext('webgl');
        
        // TEXTURE SUPPORT (Mobile Fix)
        let texType;
        const extHalfFloat = gl.getExtension('OES_texture_half_float');
        const extHalfFloatLinear = gl.getExtension('OES_texture_half_float_linear');
        if(extHalfFloat && extHalfFloatLinear) texType = extHalfFloat.HALF_FLOAT_OES;
        else texType = gl.FLOAT;

        // SHADERS (Remapped for Holographic Vibrance)
        const baseV = `attribute vec2 aPosition; varying vec2 vUv; void main() { vUv = aPosition * 0.5 + 0.5; gl_Position = vec4(aPosition, 0.0, 1.0); }`;
        const splatF = `precision mediump float; varying vec2 vUv; uniform sampler2D uTarget; uniform float uAspectRatio; uniform vec3 uColor; uniform vec2 uPoint; uniform float uRadius; void main() { vec2 p = vUv - uPoint.xy; p.x *= uAspectRatio; vec3 splat = exp(-dot(p, p) / uRadius) * uColor; vec3 base = texture2D(uTarget, vUv).xyz; gl_FragColor = vec4(base + splat, 1.0); }`;
        const advectF = `precision mediump float; varying vec2 vUv; uniform sampler2D uVelocity; uniform sampler2D uSource; uniform vec2 uTexelSize; uniform float uDt; uniform float uDissipation; void main() { vec2 coord = vUv - uDt * texture2D(uVelocity, vUv).xy * uTexelSize; gl_FragColor = uDissipation * texture2D(uSource, coord); }`;
        const divF = `precision mediump float; varying vec2 vUv; uniform sampler2D uVelocity; uniform vec2 uTexelSize; void main() { float L = texture2D(uVelocity, vUv - vec2(uTexelSize.x, 0.0)).x; float R = texture2D(uVelocity, vUv + vec2(uTexelSize.x, 0.0)).x; float T = texture2D(uVelocity, vUv + vec2(0.0, uTexelSize.y)).y; float B = texture2D(uVelocity, vUv - vec2(0.0, uTexelSize.y)).y; float div = 0.5 * (R - L + T - B); gl_FragColor = vec4(div, 0.0, 0.0, 1.0); }`;
        const pressF = `precision mediump float; varying vec2 vUv; uniform sampler2D uPressure; uniform sampler2D uDivergence; uniform vec2 uTexelSize; void main() { float L = texture2D(uPressure, vUv - vec2(uTexelSize.x, 0.0)).x; float R = texture2D(uPressure, vUv + vec2(uTexelSize.x, 0.0)).x; float T = texture2D(uPressure, vUv + vec2(0.0, uTexelSize.y)).x; float B = texture2D(uPressure, vUv - vec2(0.0, uTexelSize.y)).x; float C = texture2D(uPressure, vUv).x; float divergence = texture2D(uDivergence, vUv).x; float pressure = (L + R + B + T - divergence) * 0.25; gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0); }`;
        const gradF = `precision mediump float; varying vec2 vUv; uniform sampler2D uPressure; uniform sampler2D uVelocity; uniform vec2 uTexelSize; void main() { float L = texture2D(uPressure, vUv - vec2(uTexelSize.x, 0.0)).x; float R = texture2D(uPressure, vUv + vec2(uTexelSize.x, 0.0)).x; float T = texture2D(uPressure, vUv + vec2(0.0, uTexelSize.y)).x; float B = texture2D(uPressure, vUv - vec2(0.0, uTexelSize.y)).x; vec2 velocity = texture2D(uVelocity, vUv).xy; velocity.xy -= vec2(R - L, T - B); gl_FragColor = vec4(velocity, 0.0, 1.0); }`;
        
        // HOLOGRAPHIC DISPLAY SHADER: Adds glow and color shift
        const displayF = `precision mediump float; varying vec2 vUv; uniform sampler2D uTexture; void main() { 
            vec3 c = texture2D(uTexture, vUv).rgb; 
            // Color Mapping: Velocity/Density -> Spectrum
            // Boost low values for glow, clamp high values
            float brightness = length(c);
            vec3 hologram = vec3(c.r * 1.5, c.g * 0.8 + c.r*0.2, c.b * 2.0); 
            gl_FragColor = vec4(hologram, 1.0); 
        }`;

        function createP(v, f) { let p = gl.createProgram(); let vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, v); gl.compileShader(vs); let fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, f); gl.compileShader(fs); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); return p; }
        function createT(w, h) { let t = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, t); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, texType, null); return t; }
        function createDoubleFBO(w, h) { let f1 = createT(w, h); let f2 = createT(w, h); let fb = gl.createFramebuffer(); return { read: f1, write: f2, fbo: fb, swap: function(){ let t=this.read; this.read=this.write; this.write=t; } }; }

        let config = { texDown: 2, denDiss: 0.96, velDiss: 0.98, curl: 30, rad: 0.005 };
        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize); resize();
        let tW = Math.floor(canvas.width / config.texDown); let tH = Math.floor(canvas.height / config.texDown);

        let pSplat = createP(baseV, splatF); let pAdv = createP(baseV, advectF); let pDiv = createP(baseV, divF);
        let pPress = createP(baseV, pressF); let pGrad = createP(baseV, gradF); let pDisp = createP(baseV, displayF);
        let den = createDoubleFBO(tW, tH); let vel = createDoubleFBO(tW, tH);
        let div = createT(tW, tH); let divFBO = gl.createFramebuffer(); let press = createDoubleFBO(tW, tH);

        const blit = (() => {
            let b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
            return (p) => {
                gl.useProgram(p);
                let a = gl.getAttribLocation(p, 'aPosition');
                gl.enableVertexAttribArray(a); gl.vertexAttribPointer(a, 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            }
        })();

        let splats = [];

        document.getElementById('startBtn').addEventListener('click', initAudio);

        // --- MAIN RENDER LOOP ---
        let lastTime = Date.now();
        function update() {
            let dt = Math.min((Date.now()-lastTime)/1000, 0.016);
            lastTime = Date.now();
            
            // GLITCH MODULATION
            if(document.getElementById('btnGlitch').classList.contains('pressed')) {
                // Randomize time step for visual stutter
                if(Math.random() > 0.5) dt = 0; 
                if(Math.random() > 0.9) {
                    // Random color injection
                    splats.push({x:Math.random(), y:Math.random(), dx:0, dy:0, c:[1,0,1]});
                }
            }

            gl.viewport(0, 0, tW, tH);

            // AUDIO REACTIVE INJECTION
            if(isInit) {
                analyser.getByteFrequencyData(dataArray);
                let bass = dataArray[4];
                let mid = dataArray[30];
                let high = dataArray[100];

                // BASS: Big pushes
                if(bass > 180) {
                    let angle = Math.random() * Math.PI * 2;
                    splats.push({
                        x: 0.5, y: 0.5,
                        dx: Math.cos(angle) * 500,
                        dy: Math.sin(angle) * 500,
                        c: [0.2, 0, 0.5] // Deep Purple
                    });
                    document.getElementById('visRing').style.transform = `scale(${1 + bass/200})`;
                }

                // MID: Orbitals
                if(mid > 100) {
                    let t = Date.now() * 0.002;
                    splats.push({
                        x: 0.5 + Math.cos(t) * 0.3,
                        y: 0.5 + Math.sin(t) * 0.3,
                        dx: Math.cos(t + 1.5) * 200,
                        dy: Math.sin(t + 1.5) * 200,
                        c: [0, 0.8, 1] // Cyan
                    });
                }

                // HIGH: Sparkles
                if(high > 50 || document.getElementById('btnShimmer').classList.contains('pressed')) {
                    splats.push({
                        x: Math.random(), y: Math.random(),
                        dx: 0, dy: 0,
                        c: [1, 1, 0.5] // White/Yellow
                    });
                }
            }

            // FLUID PHYSICS
            if(splats.length > 0) {
                gl.useProgram(pSplat);
                gl.uniform1f(gl.getUniformLocation(pSplat, 'uAspectRatio'), canvas.width/canvas.height);
                for(let s of splats) {
                    gl.uniform1i(gl.getUniformLocation(pSplat, 'uTarget'), den.read);
                    gl.uniform2f(gl.getUniformLocation(pSplat, 'uPoint'), s.x, s.y);
                    gl.uniform3f(gl.getUniformLocation(pSplat, 'uColor'), s.c[0], s.c[1], s.c[2]);
                    gl.uniform1f(gl.getUniformLocation(pSplat, 'uRadius'), config.rad);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, den.write); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, den.write, 0);
                    blit(pSplat); den.swap();

                    gl.uniform1i(gl.getUniformLocation(pSplat, 'uTarget'), vel.read);
                    gl.uniform3f(gl.getUniformLocation(pSplat, 'uColor'), s.dx, s.dy, 1);
                    gl.bindFramebuffer(gl.FRAMEBUFFER, vel.write); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, vel.write, 0);
                    blit(pSplat); vel.swap();
                }
                splats = [];
            }

            gl.useProgram(pAdv);
            gl.uniform2f(gl.getUniformLocation(pAdv, 'uTexelSize'), 1/tW, 1/tH);
            gl.uniform1f(gl.getUniformLocation(pAdv, 'uDt'), dt);
            gl.uniform1i(gl.getUniformLocation(pAdv, 'uVelocity'), 0); gl.uniform1i(gl.getUniformLocation(pAdv, 'uSource'), 0);
            gl.uniform1f(gl.getUniformLocation(pAdv, 'uDissipation'), config.velDiss);
            gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, vel.read);
            gl.bindFramebuffer(gl.FRAMEBUFFER, vel.write); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, vel.write, 0);
            blit(pAdv); vel.swap();
            gl.uniform1f(g
