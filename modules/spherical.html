<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Threshold Garden âœ¨ ENHANCED</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #8b00ff;
            font-size: 24px;
            z-index: 1000;
            text-align: center;
        }
        
        #loading.hidden {
            display: none;
        }
        
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 100;
            max-width: 300px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
        }
        
        .touch-indicator {
            position: fixed;
            width: 60px;
            height: 60px;
            border: 2px solid #8b00ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, rgba(139, 0, 255, 0.3), transparent);
            animation: pulse 0.5s ease-out;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading Threshold Garden...</div>
        <div style="margin-top: 10px; font-size: 16px;">âœ¨ğŸŒŠğŸ’«</div>
    </div>
    
    <div id="info">
        <strong>Threshold Garden ENHANCED</strong><br>
        ğŸ–±ï¸ Mouse/Touch to create ripples<br>
        ğŸ“± Multi-touch supported<br>
        ğŸ’« Gravitational field active<br>
        âœ¨ Post-processing enabled
    </div>
    
    <div id="canvas-container"></div>
    
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <!-- MOBILE-COMPATIBLE SCRIPT LOADING                         -->
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    
    <!-- Load Three.js DIRECTLY (no import maps!) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WAIT FOR THREE.JS TO LOAD
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Check if THREE is loaded
        function waitForThree(callback) {
            if (typeof THREE !== 'undefined') {
                callback();
            } else {
                setTimeout(() => waitForThree(callback), 100);
            }
        }
        
        waitForThree(function() {
            console.log('âœ¨ Three.js loaded successfully!');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SETUP SCENE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const container = document.getElementById('canvas-container');
            const loading = document.getElementById('loading');
            
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 8;
            
            const renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            console.log('âœ¨ Scene created!');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SPLIT MESH SPHERE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const sphereGeometry = new THREE.IcosahedronGeometry(1.5, 2);
            
            // Wireframe edges
            const edges = new THREE.EdgesGeometry(sphereGeometry, 15);
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x8b00ff,
                linewidth: 2
            });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            scene.add(wireframe);
            
            // Glowing faces
            const faceMaterial = new THREE.MeshBasicMaterial({
                color: 0x8b00ff,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const sphere = new THREE.Mesh(sphereGeometry, faceMaterial);
            scene.add(sphere);
            
            // Vertex points
            const vertices = [];
            const positions = sphereGeometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                vertices.push(new THREE.Vector3(positions[i], positions[i+1], positions[i+2]));
            }
            
            const pointsGeometry = new THREE.BufferGeometry().setFromPoints(vertices);
            const pointsMaterial = new THREE.PointsMaterial({
                color: 0xff00ff,
                size: 0.1,
                blending: THREE.AdditiveBlending
            });
            const points = new THREE.Points(pointsGeometry, pointsMaterial);
            scene.add(points);
            
            console.log('âœ¨ Split mesh sphere created!');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GRAVITATIONAL FIELD
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const fieldSize = 20;
            const fieldResolution = 12; // Reduced for mobile
            const fieldPositions = [];
            const fieldColors = [];
            
            for (let x = -fieldSize/2; x <= fieldSize/2; x += fieldSize/fieldResolution) {
                for (let y = -fieldSize/2; y <= fieldSize/2; y += fieldSize/fieldResolution) {
                    for (let z = -fieldSize/2; z <= fieldSize/2; z += fieldSize/fieldResolution) {
                        fieldPositions.push(x, y, z);
                        
                        const dist = Math.sqrt(x*x + y*y + z*z);
                        const intensity = 1 - Math.min(dist / (fieldSize/2), 1);
                        fieldColors.push(intensity, 0, intensity * 0.5);
                    }
                }
            }
            
            const fieldGeometry = new THREE.BufferGeometry();
            fieldGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fieldPositions, 3));
            fieldGeometry.setAttribute('color', new THREE.Float32BufferAttribute(fieldColors, 3));
            
            const fieldMaterial = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            const fieldMesh = new THREE.Points(fieldGeometry, fieldMaterial);
            scene.add(fieldMesh);
            
            console.log('âœ¨ Gravitational field created!');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PARTICLE SYSTEM WITH PHYSICS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const particleCount = 5000; // Reduced for mobile
            const particlesGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const radius = 3 + Math.random() * 4;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particlePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                particlePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                particlePositions[i * 3 + 2] = radius * Math.cos(phi);
                
                velocities[i * 3] = (Math.random() - 0.5) * 0.02;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
                
                const color = new THREE.Color();
                color.setHSL(i / particleCount, 1.0, 0.5);
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.9
            });
            
            const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particleSystem);
            
            console.log('âœ¨ Particles created!');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MULTI-TOUCH INPUT
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const touches = new Map();
            const mouse = { x: 0, y: 0, down: false };
            const ripples = [];
            
            function screenTo3D(screenX, screenY) {
                const x = (screenX / window.innerWidth) * 2 - 1;
                const y = -(screenY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera({ x, y }, camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersect = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersect);
                
                return intersect;
            }
            
            function showTouchFeedback(x, y) {
                const indicator = document.createElement('div');
                indicator.className = 'touch-indicator';
                indicator.style.left = x + 'px';
                indicator.style.top = y + 'px';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 500);
            }
            
            function createRipple(position) {
                ripples.push({
                    position: position.clone(),
                    radius: 0,
                    maxRadius: 5,
                    strength: 2,
                    life: 1.0
                });
                
                sphere.scale.set(1.3, 1.3, 1.3);
                wireframe.scale.set(1.3, 1.3, 1.3);
                setTimeout(() => {
                    sphere.scale.set(1, 1, 1);
                    wireframe.scale.set(1, 1, 1);
                }, 150);
            }
            
            // Mouse events
            document.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            document.addEventListener('mousedown', (e) => {
                mouse.down = true;
                showTouchFeedback(e.clientX, e.clientY);
                createRipple(screenTo3D(e.clientX, e.clientY));
            });
            
            document.addEventListener('mouseup', () => {
                mouse.down = false;
            });
            
            // Touch events
            document.addEventListener('touchstart', (e) => {
                e.preventDefault();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    touches.set(touch.identifier, {
                        x: touch.clientX,
                        y: touch.clientY,
                        position3D: screenTo3D(touch.clientX, touch.clientY)
                    });
                    
                    showTouchFeedback(touch.clientX, touch.clientY);
                    createRipple(screenTo3D(touch.clientX, touch.clientY));
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touches.has(touch.identifier)) {
                        touches.set(touch.identifier, {
                            x: touch.clientX,
                            y: touch.clientY,
                            position3D: screenTo3D(touch.clientX, touch.clientY)
                        });
                    }
                }
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    touches.delete(e.changedTouches[i].identifier);
                }
            }, { passive: false });
            
            console.log('âœ¨ Multi-touch enabled!');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PHYSICS UPDATE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function updatePhysics() {
                const posArray = particlesGeometry.attributes.position.array;
                const sphereRadius = 1.5;
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    let px = posArray[i3];
                    let py = posArray[i3 + 1];
                    let pz = posArray[i3 + 2];
                    
                    let vx = velocities[i3];
                    let vy = velocities[i3 + 1];
                    let vz = velocities[i3 + 2];
                    
                    // Gravity to center
                    const distToCenter = Math.sqrt(px*px + py*py + pz*pz);
                    if (distToCenter > 0.1) {
                        const gravity = 0.001;
                        vx -= px / distToCenter * gravity;
                        vy -= py / distToCenter * gravity;
                        vz -= pz / distToCenter * gravity;
                    }
                    
                    // Sphere collision
                    if (distToCenter < sphereRadius + 0.1 && distToCenter > sphereRadius - 0.1) {
                        const nx = px / distToCenter;
                        const ny = py / distToCenter;
                        const nz = pz / distToCenter;
                        
                        const dot = vx * nx + vy * ny + vz * nz;
                        vx -= 2 * dot * nx;
                        vy -= 2 * dot * ny;
                        vz -= 2 * dot * nz;
                        
                        vx *= 0.8;
                        vy *= 0.8;
                        vz *= 0.8;
                        
                        px = nx * (sphereRadius + 0.15);
                        py = ny * (sphereRadius + 0.15);
                        pz = nz * (sphereRadius + 0.15);
                    }
                    
                    // Ripple forces
                    ripples.forEach(ripple => {
                        const dx = px - ripple.position.x;
                        const dy = py - ripple.position.y;
                        const dz = pz - ripple.position.z;
                        const distToRipple = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (Math.abs(distToRipple - ripple.radius) < 0.5) {
                            const force = ripple.strength * ripple.life;
                            if (distToRipple > 0.01) {
                                vx += (dx / distToRipple) * force * 0.01;
                                vy += (dy / distToRipple) * force * 0.01;
                                vz += (dz / distToRipple) * force * 0.01;
                            }
                        }
                    });
                    
                    // Touch attraction
                    touches.forEach(touch => {
                        const dx = touch.position3D.x - px;
                        const dy = touch.position3D.y - py;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < 2) {
                            vx += dx * 0.008;
                            vy += dy * 0.008;
                        }
                    });
                    
                    // Friction
                    vx *= 0.99;
                    vy *= 0.99;
                    vz *= 0.99;
                    
                    // Update position
                    px += vx;
                    py += vy;
                    pz += vz;
                    
                    // Boundary
                    if (distToCenter > 15) {
                        const scale = 15 / distToCenter;
                        px *= scale;
                        py *= scale;
                        pz *= scale;
                        vx *= -0.5;
                        vy *= -0.5;
                        vz *= -0.5;
                    }
                    
                    posArray[i3] = px;
                    posArray[i3 + 1] = py;
                    posArray[i3 + 2] = pz;
                    
                    velocities[i3] = vx;
                    velocities[i3 + 1] = vy;
                    velocities[i3 + 2] = vz;
                }
                
                particlesGeometry.attributes.position.needsUpdate = true;
            }
            
            function updateRipples() {
                for (let i = ripples.length - 1; i >= 0; i--) {
                    ripples[i].radius += 0.1;
                    ripples[i].life -= 0.02;
                    
                    if (ripples[i].life <= 0 || ripples[i].radius > ripples[i].maxRadius) {
                        ripples.splice(i, 1);
                    }
                }
            }
            
            function updateField(time) {
                const colors = fieldGeometry.attributes.color.array;
                
                for (let i = 0; i < fieldPositions.length / 3; i++) {
                    cons radius = 3 + Math.random() * 4;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                particlePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                particlePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                particlePositions[i * 3 + 2] = radius * Math.cos(phi);
                
                velocities[i * 3] = (Math.random() - 0.5) * 0.02;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;
                
                const color = new THREE.Color();
                color.setHSL(i / particleCount, 1.0, 0.5);
                particleColors[i * 3] = color.r;
                particleColors[i * 3 + 1] = color.g;
                particleColors[i * 3 + 2] = color.b;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.9
            });
            
            const particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particleSystem);
            
            console.log('âœ¨ Particles created!');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MULTI-TOUCH INPUT
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const touches = new Map();
            const mouse = { x: 0, y: 0, down: false };
            const ripples = [];
            
            function screenTo3D(screenX, screenY) {
                const x = (screenX / window.innerWidth) * 2 - 1;
                const y = -(screenY / window.innerHeight) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera({ x, y }, camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const intersect = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersect);
                
                return intersect;
            }
            
            function showTouchFeedback(x, y) {
                const indicator = document.createElement('div');
                indicator.className = 'touch-indicator';
                indicator.style.left = x + 'px';
                indicator.style.top = y + 'px';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 500);
            }
            
            function createRipple(position) {
                ripples.push({
                    position: position.clone(),
                    radius: 0,
                    maxRadius: 5,
                    strength: 2,
                    life: 1.0
                });
                
                sphere.scale.set(1.3, 1.3, 1.3);
                wireframe.scale.set(1.3, 1.3, 1.3);
                setTimeout(() => {
                    sphere.scale.set(1, 1, 1);
                    wireframe.scale.set(1, 1, 1);
                }, 150);
            }
            
            // Mouse events
            document.addEventListener('mousemove', (e) => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            
            document.addEventListener('mousedown', (e) => {
                mouse.down = true;
                showTouchFeedback(e.clientX, e.clientY);
                createRipple(screenTo3D(e.clientX, e.clientY));
            });
            
            document.addEventListener('mouseup', () => {
                mouse.down = false;
            });
            
            // Touch events
            document.addEventListener('touchstart', (e) => {
                e.preventDefault();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    touches.set(touch.identifier, {
                        x: touch.clientX,
                        y: touch.clientY,
                        position3D: screenTo3D(touch.clientX, touch.clientY)
                    });
                    
                    showTouchFeedback(touch.clientX, touch.clientY);
                    createRipple(screenTo3D(touch.clientX, touch.clientY));
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (touches.has(touch.identifier)) {
                        touches.set(touch.identifier, {
                            x: touch.clientX,
                            y: touch.clientY,
                            position3D: screenTo3D(touch.clientX, touch.clientY)
                        });
                    }
                }
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                e.preventDefault();
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    touches.delete(e.changedTouches[i].identifier);
                }
            }, { passive: false });
            
            console.log('âœ¨ Multi-touch enabled!');
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PHYSICS UPDATE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function updatePhysics() {
                const posArray = particlesGeometry.attributes.position.array;
                const sphereRadius = 1.5;
                
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    
                    let px = posArray[i3];
                    let py = posArray[i3 + 1];
                    let pz = posArray[i3 + 2];
                    
                    let vx = velocities[i3];
                    let vy = velocities[i3 + 1];
                    let vz = velocities[i3 + 2];
                    
                    // Gravity to center
                    const distToCenter = Math.sqrt(px*px + py*py + pz*pz);
                    if (distToCenter > 0.1) {
                        const gravity = 0.001;
                        vx -= px / distToCenter * gravity;
                        vy -= py / distToCenter * gravity;
                        vz -= pz / distToCenter * gravity;
                    }
                    
                    // Sphere collision
                    if (distToCenter < sphereRadius + 0.1 && distToCenter > sphereRadius - 0.1) {
                        const nx = px / distToCenter;
                        const ny = py / distToCenter;
                        const nz = pz / distToCenter;
                        
                        const dot = vx * nx + vy * ny + vz * nz;
                        vx -= 2 * dot * nx;
                        vy -= 2 * dot * ny;
                        vz -= 2 * dot * nz;
                        
                        vx *= 0.8;
                        vy *= 0.8;
                        vz *= 0.8;
                        
                        px = nx * (sphereRadius + 0.15);
                        py = ny * (sphereRadius + 0.15);
                        pz = nz * (sphereRadius + 0.15);
                    }
                    
                    // Ripple forces
                    ripples.forEach(ripple => {
                        const dx = px - ripple.position.x;
                        const dy = py - ripple.position.y;
                        const dz = pz - ripple.position.z;
                        const distToRipple = Math.sqrt(dx*dx + dy*dy + dz*dz);
                        
                        if (Math.abs(distToRipple - ripple.radius) < 0.5) {
                            const force = ripple.strength * ripple.life;
                            if (distToRipple > 0.01) {
                                vx += (dx / distToRipple) * force * 0.01;
                                vy += (dy / distToRipple) * force * 0.01;
                                vz += (dz / distToRipple) * force * 0.01;
                            }
                        }
                    });
                    
                    // Touch attraction
                    touches.forEach(touch => {
                        const dx = touch.position3D.x - px;
                        const dy = touch.position3D.y - py;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < 2) {
                            vx += dx * 0.008;
                            vy += dy * 0.008;
                        }
                    });
                    
                    // Friction
                    vx *= 0.99;
                    vy *= 0.99;
                    vz *= 0.99;
                    
                    // Update position
                    px += vx;
                    py += vy;
                    pz += vz;
                    
                    // Boundary
                    if (distToCenter > 15) {
                        const scale = 15 / distToCenter;
                        px *= scale;
                        py *= scale;
                        pz *= scale;
                        vx *= -0.5;
                        vy *= -0.5;
                        vz *= -0.5;
                    }
                    
                    posArray[i3] = px;
                    posArray[i3 + 1] = py;
                    posArray[i3 + 2] = pz;
                    
                    velocities[i3] = vx;
                    velocities[i3 + 1] = vy;
                    velocities[i3 + 2] = vz;
                }
                
                particlesGeometry.attributes.position.needsUpdate = true;
            }
            
            function updateRipples() {
                for (let i = ripples.length - 1; i >= 0; i--) {
                    ripples[i].radius += 0.1;
                    ripples[i].life -= 0.02;
                    
                    if (ripples[i].life <= 0 || ripples[i].radius > ripples[i].maxRadius) {
                        ripples.splice(i, 1);
                    }
                }
            }
            
            function updateField(time) {
                const colors = fieldGeometry.attributes.color.array;
                
                for (let i = 0; i < fieldPositions.length / 3; i++) {
                    const x = fieldPositions[i * 3];
                    const y = fieldPositions[i * 3 + 1];
                    const z = fieldPositions[i * 3 + 2];
                    const dist = Math.sqrt(x*x + y*y + z*z);
                    
                    const pulse = Math.sin(time * 0.001 + dist * 0.5) * 0.5 + 0.5;
                    const intensity = (1 - Math.min(dist / 10, 1)) * pulse;
                    
                    colors[i * 3] = intensity;
                    colors[i * 3 + 1] = 0;
                    colors[i * 3 + 2] = intensity * 0.5;
                }
                
                fieldGeometry.attributes.color.needsUpdate = true;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ANIMATION LOOP
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            function animate() {
                requestAnimationFrame(animate);
                
                const time = performance.now();
                
                sphere.rotation.x += 0.003;
                sphere.rotation.y += 0.005;
                wireframe.rotation.x += 0.003;
                wireframe.rotation.y += 0.005;
                points.rotation.x += 0.003;
                points.rotation.y += 0.005;
                
                particleSystem.rotation.y += 0.0005;
                fieldMesh.rotation.x += 0.001;
                fieldMesh.rotation.y += 0.002;
                
                updatePhysics();
                updateRipples();
                updateField(time);
                
                renderer.render(scene, camera);
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RESIZE HANDLER
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // START!
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            loading.classList.add('hidden');
            animate();
            
            console.log('âœ¨âœ¨âœ¨ THRESHOLD GARDEN IS ALIVE! âœ¨âœ¨âœ¨');
        });
    </script>
</body>
</html>
