<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üå∏ Physics Snow Globe üå∏</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            height: 100vh;
            font-family: 'Georgia', serif;
            background: #000;
            touch-action: none;
            position: relative;
        }

        .texture-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            transition: all 0.5s ease;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        .globe-border {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vmin;
            height: 90vmin;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
            box-shadow: 
                inset 0 0 50px rgba(255, 255, 255, 0.1),
                0 0 50px rgba(255, 255, 255, 0.2);
        }

        .custom-cursor {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.1s ease;
            mix-blend-mode: screen;
            filter: blur(5px);
        }

        .controls {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            z-index: 100;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 50px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            transform: scale(1.2);
            background: rgba(255, 255, 255, 0.2);
        }

        .control-btn.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.9);
            transform: scale(1.3);
        }

        .bottom-controls {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            z-index: 100;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 50px;
        }

        .action-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            font-family: 'Georgia', serif;
        }

        .action-btn:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.25);
        }

        .dissolve-btn {
            background: rgba(255, 0, 128, 0.3);
            border: 2px solid rgba(255, 0, 128, 0.6);
            animation: pulseDanger 2s ease-in-out infinite;
        }

        @keyframes pulseDanger {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 128, 0.4); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 128, 0.8); }
        }

        .triskel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            pointer-events: none;
            z-index: 60;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .triskel.active {
            opacity: 1;
        }

        @keyframes shimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
    </style>
</head>
<body>
    <div class="texture-background" id="textureBackground"></div>
    <canvas id="canvas"></canvas>
    <div class="globe-border"></div>
    
    <svg class="triskel" id="triskel" viewBox="0 0 200 200">
        <g id="triskelSpinner">
            <path d="M100,100 L100,20 A80,80 0 0,1 169,65 L100,100" 
                  fill="none" stroke="rgba(255, 0, 128, 0.8)" stroke-width="3"/>
            <path d="M100,100 L169,65 A80,80 0 0,1 131,180 L100,100" 
                  fill="none" stroke="rgba(255, 0, 255, 0.8)" stroke-width="3"/>
            <path d="M100,100 L131,180 A80,80 0 0,1 100,20 L100,100" 
                  fill="none" stroke="rgba(128, 0, 255, 0.8)" stroke-width="3"/>
            <circle cx="100" cy="100" r="15" fill="rgba(255, 0, 200, 0.5)"/>
        </g>
    </svg>
    
    <div class="custom-cursor" id="cursor"></div>
    
    <div class="controls">
        <button class="control-btn active" data-texture="silk">üå∏</button>
        <button class="control-btn" data-texture="fur">üêª</button>
        <button class="control-btn" data-texture="honey">üçØ</button>
        <button class="control-btn" data-texture="water">üíß</button>
        <button class="control-btn" data-texture="velvet">üíú</button>
        <button class="control-btn" data-texture="clouds">‚òÅÔ∏è</button>
        <button class="control-btn" data-texture="holographic">üåà</button>
    </div>

    <div class="bottom-controls">
        <button class="action-btn" id="clearBtn">üóëÔ∏è Clear</button>
        <button class="action-btn" id="saveBtn">üíæ Save</button>
        <button class="action-btn" id="shakeBtn">üåÄ Shake</button>
        <button class="action-btn" id="spiralBtn">üåÄ Spiral</button>
        <button class="action-btn dissolve-btn" id="dissolveBtn" style="display: none;">‚ö†Ô∏è Dissolve</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const background = document.getElementById('textureBackground');
        const cursor = document.getElementById('cursor');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let currentTexture = 'silk';
        let drawing = false;
        let particles = [];
        let spiraling = false;
        let spiralAngle = 0;
        let dissolving = false;
        let triskelAngle = 0;
        
        // Snow globe bounds (circular)
        const globeRadius = Math.min(canvas.width, canvas.height) * 0.45;
        const globeCenterX = canvas.width / 2;
        const globeCenterY = canvas.height / 2;

        const textures = {
            silk: {
                color: ['#ffc0cb', '#ffb6c1', '#ffd4ff', '#ffe4f0', '#ff69b4'],
                size: [3, 7],
                background: `radial-gradient(ellipse at 20% 30%, rgba(255, 182, 193, 0.6) 0%, transparent 50%),
                    radial-gradient(ellipse at 80% 70%, rgba(255, 212, 255, 0.5) 0%, transparent 50%),
                    linear-gradient(135deg, #fff0f5 0%, #ffe4f0 25%, #ffd4e8 50%, #ffb6c1 75%, #ffc0cb 100%)`,
                density: 0.3,
                bounce: 0.3,
                friction: 0.98
            },
            fur: {
                color: ['#d4a574', '#c19a6b', '#e6c9a8', '#f5deb3', '#daa520'],
                size: [4, 8],
                background: `radial-gradient(circle at 30% 40%, rgba(245, 222, 179, 0.8) 0%, transparent 60%),
                    radial-gradient(circle at 70% 60%, rgba(218, 165, 32, 0.4) 0%, transparent 60%),
                    radial-gradient(circle at 40% 40%, #f5deb3 0%, #e6c9a8 30%, #daa520 60%, #d4a574 100%)`,
                density: 0.5,
                bounce: 0.2,
                friction: 0.95
            },
            honey: {
                color: ['#ffaa00', '#ff8800', '#ffcc66', '#ffd700', '#ffb347'],
                size: [5, 10],
                background: `radial-gradient(circle at 40% 30%, rgba(255, 215, 0, 0.6) 0%, transparent 50%),
                    radial-gradient(ellipse at 60% 70%, rgba(255, 140, 0, 0.5) 0%, transparent 60%),
                    radial-gradient(ellipse at 50% 60%, #ffe4b5 0%, #ffd700 40%, #ffaa00 70%, #ff8800 100%)`,
                density: 0.9,
                bounce: 0.1,
                friction: 0.7
            },
            water: {
                color: ['#4dd0e1', '#00bcd4', '#b2ebf2', '#80deea', '#26c6da'],
                size: [2, 5],
                background: `radial-gradient(circle at 30% 20%, rgba(178, 235, 242, 0.7) 0%, transparent 50%),
                    radial-gradient(circle at 70% 80%, rgba(0, 188, 212, 0.5) 0%, transparent 50%),
                    linear-gradient(180deg, #e0f7fa 0%, #b2ebf2 30%, #80deea 60%, #00bcd4 100%)`,
                density: 0.2,
                bounce: 0.6,
                friction: 0.99
            },
            velvet: {
                color: ['#8b4789', '#9b59b6', '#c39bd3', '#d7bde2', '#e8daef'],
                size: [4, 9],
                background: `radial-gradient(ellipse at 25% 30%, rgba(232, 218, 239, 0.6) 0%, transparent 50%),
                    radial-gradient(circle at 75% 70%, rgba(155, 89, 182, 0.5) 0%, transparent 60%),
                    radial-gradient(circle at 30% 60%, #e8daef 0%, #d7bde2 30%, #c39bd3 60%, #9b59b6 85%, #8b4789 100%)`,
                density: 0.4,
                bounce: 0.25,
                friction: 0.96
            },
            clouds: {
                color: ['#ffffff', '#f0f0f0', '#e8e8e8', '#f8f8ff', '#fffafa'],
                size: [6, 12],
                background: `radial-gradient(ellipse at 20% 40%, rgba(255, 255, 255, 0.9) 0%, transparent 50%),
                    radial-gradient(circle at 80% 60%, rgba(248, 248, 255, 0.7) 0%, transparent 50%),
                    linear-gradient(160deg, #ffffff 0%, #f8f8ff 30%, #f0f0f0 60%, #e8e8e8 100%)`,
                density: 0.15,
                bounce: 0.4,
                friction: 0.99
            },
            holographic: {
                color: ['#ff00ff', '#00ffff', '#ffff00', '#ff0080', '#00ff80', '#8000ff'],
                size: [3, 7],
                background: `radial-gradient(circle at 30% 30%, rgba(255, 0, 255, 0.4) 0%, transparent 50%),
                    radial-gradient(circle at 70% 70%, rgba(0, 255, 255, 0.4) 0%, transparent 50%),
                    linear-gradient(45deg, #ff00ff 0%, #00ffff 14%, #ffff00 28%, #ff0080 42%, #00ff80 57%, #8000ff 71%, #ff00ff 85%, #00ffff 100%)`,
                density: 0.25,
                bounce: 0.5,
                friction: 0.97
            }
        };

        class Particle {
            constructor(x, y, texture) {
                this.x = x;
                this.y = y;
                const tex = textures[texture];
                this.color = tex.color[Math.floor(Math.random() * tex.color.length)];
                this.size = Math.random() * (tex.size[1] - tex.size[0]) + tex.size[0];
                this.texture = texture;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.settled = false;
            }

            update() {
                if (this.settled && !spiraling && !dissolving) return;
                
                const tex = textures[this.texture];
                
                // Spiral rotation effect
                if (spiraling) {
                    const dx = this.x - globeCenterX;
                    const dy = this.y - globeCenterY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Rotate around center
                    const currentAngle = Math.atan2(dy, dx);
                    const newAngle = currentAngle + 0.02;
                    this.x = globeCenterX + Math.cos(newAngle) * dist;
                    this.y = globeCenterY + Math.sin(newAngle) * dist;
                    
                    this.settled = false;
                }
                
                // Dissolve vortex effect
                if (dissolving) {
                    const dx = globeCenterX - this.x;
                    const dy = globeCenterY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 5) {
                        // Pull toward center in spiral
                        const pullStrength = 0.5;
                        const angle = Math.atan2(dy, dx);
                        const spiralOffset = triskelAngle * 0.1;
                        
                        this.vx += Math.cos(angle + spiralOffset) * pullStrength;
                        this.vy += Math.sin(angle + spiralOffset) * pullStrength;
                        
                        this.x += this.vx;
                        this.y += this.vy;
                        
                        this.vx *= 0.95;
                        this.vy *= 0.95;
                    } else {
                        // Dissolve at center
                        this.size *= 0.95;
                        if (this.size < 0.5) {
                            particles = particles.filter(p => p !== this);
                        }
                    }
                    return;
                }
                
                // Apply gravity
                this.vy += tex.density;
                
                // Apply friction
                this.vx *= tex.friction;
                this.vy *= tex.friction;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Check globe boundary (circular)
                const dx = this.x - globeCenterX;
                const dy = this.y - globeCenterY;
                const distFromCenter = Math.sqrt(dx * dx + dy * dy);
                
                if (distFromCenter + this.size > globeRadius) {
                    // Push back inside
                    const angle = Math.atan2(dy, dx);
                    this.x = globeCenterX + Math.cos(angle) * (globeRadius - this.size);
                    this.y = globeCenterY + Math.sin(angle) * (globeRadius - this.size);
                    
                    // Bounce
                    const normalX = dx / distFromCenter;
                    const normalY = dy / distFromCenter;
                    const dot = this.vx * normalX + this.vy * normalY;
                    this.vx -= 2 * dot * normalX * tex.bounce;
                    this.vy -= 2 * dot * normalY * tex.bounce;
                    
                    // Check if settled
                    if (Math.abs(this.vx) < 0.5 && Math.abs(this.vy) < 0.5) {
                        this.settled = true;
                        this.vx = 0;
                        this.vy = 0;
                    }
                }
                
                // Check collision with other particles
                for (let other of particles) {
                    if (other === this || !other.settled) continue;
                    
                    const dx2 = other.x - this.x;
                    const dy2 = other.y - this.y;
                    const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                    const minDist = this.size + other.size;
                    
                    if (dist < minDist) {
                        // Push apart
                        const angle = Math.atan2(dy2, dx2);
                        this.x = other.x - Math.cos(angle) * minDist;
                        this.y = other.y - Math.sin(angle) * minDist;
                        
                        // Bounce
                        this.vx *= -tex.bounce;
                        this.vy *= -tex.bounce;
                        
                        // Check if settled
                        if (Math.abs(this.vx) < 0.5 && Math.abs(this.vy) < 0.5) {
                            this.settled = true;
                            this.vx = 0;
                            this.vy = 0;
                        }
                    }
                }
            }

            draw() {
                const r = parseInt(this.color.slice(1, 3), 16);
                const g = parseInt(this.color.slice(3, 5), 16);
                const b = parseInt(this.color.slice(5, 7), 16);
                
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function createParticles(x, y) {
            const tex = textures[currentTexture];
            const count = Math.floor(Math.random() * 8) + 5;
            
            for (let i = 0; i < count; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const offsetY = (Math.random() - 0.5) * 20;
                particles.push(new Particle(x + offsetX, y + offsetY, currentTexture));
            }
        }

        function animate() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Rotate triskel
            if (dissolving) {
                triskelAngle += 0.1;
                const spinner = document.getElementById('triskelSpinner');
                if (spinner) {
                    spinner.style.transform = `rotate(${triskelAngle * 10}deg)`;
                    spinner.style.transformOrigin = '100px 100px';
                }
            }
            
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        // Events
        canvas.addEventListener('mousedown', (e) => {
            drawing = true;
            createParticles(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (drawing) createParticles(e.clientX, e.clientY);
        });

        canvas.addEventListener('mouseup', () => { drawing = false; });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            drawing = true;
            for (let touch of e.touches) {
                createParticles(touch.clientX, touch.clientY);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (drawing) {
                for (let touch of e.touches) {
                    createParticles(touch.clientX, touch.clientY);
                }
            }
        });

        canvas.addEventListener('touchend', () => { drawing = false; });

        document.addEventListener('mousemove', (e) => {
            cursor.style.left = e.clientX + 'px';
            cursor.style.top = e.clientY + 'px';
        });

        document.querySelectorAll('.control-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                currentTexture = btn.dataset.texture;
                document.querySelectorAll('.control-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const tex = textures[currentTexture];
                background.style.background = tex.background;
                background.style.backgroundSize = '400% 400%';
                cursor.style.background = `radial-gradient(circle, ${tex.color[0]}, transparent)`;
            });
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            particles = [];
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `snow-globe-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });

        document.getElementById('shakeBtn').addEventListener('click', () => {
            particles.forEach(p => {
                p.settled = false;
                p.vx = (Math.random() - 0.5) * 20;
                p.vy = (Math.random() - 0.5) * 20;
            });
        });

        document.getElementById('spiralBtn').addEventListener('click', () => {
            spiraling = !spiraling;
            const btn = document.getElementById('spiralBtn');
            const dissolveBtn = document.getElementById('dissolveBtn');
            
            if (spiraling) {
                btn.textContent = '‚è∏Ô∏è Stop Spiral';
                btn.style.background = 'rgba(255, 200, 0, 0.3)';
                dissolveBtn.style.display = 'block';
                particles.forEach(p => p.settled = false);
            } else {
                btn.textContent = 'üåÄ Spiral';
                btn.style.background = 'rgba(255, 255, 255, 0.15)';
                if (!dissolving) {
                    dissolveBtn.style.display = 'none';
                }
            }
        });

        document.getElementById('dissolveBtn').addEventListener('click', () => {
            dissolving = !dissolving;
            const btn = document.getElementById('dissolveBtn');
            const triskel = document.getElementById('triskel');
            
            if (dissolving) {
                btn.textContent = '‚èπÔ∏è Stop Dissolve';
                triskel.classList.add('active');
                particles.forEach(p => p.settled = false);
            } else {
                btn.textContent = '‚ö†Ô∏è Dissolve';
                triskel.classList.remove('active');
            }
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // Initialize
        const tex = textures[currentTexture];
        background.style.background = tex.background;
        background.style.backgroundSize = '400% 400%';
        cursor.style.background = `radial-gradient(circle, ${tex.color[0]}, transparent)`;
        
        animate();
    </script>
</body>
</html>
