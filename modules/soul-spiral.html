<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ðŸŒ€ Fluid Soul Clock ðŸ¦‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
        }

        body {
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a4a 100%);
            font-family: 'Courier New', monospace;
            color: #ff66ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ff00ff;
            animation: glow 3s infinite alternate;
            width: 100%;
            max-width: 500px;
        }

        .title {
            font-size: clamp(18px, 5vw, 28px);
            margin-bottom: 8px;
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: clamp(10px, 3vw, 14px);
            color: #ffcc00;
            opacity: 0.8;
        }

        .clock-container {
            position: relative;
            width: 90vmin;
            height: 90vmin;
            max-width: 400px;
            max-height: 400px;
            margin: 0 auto;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            border: 3px solid #00ffff;
            border-radius: 50%;
            background: rgba(0, 0, 30, 0.8);
            box-shadow: 
                0 0 30px #ff00ff,
                inset 0 0 30px rgba(0, 255, 255, 0.2);
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 500px;
        }

        .btn {
            padding: 12px 20px;
            font-family: 'Courier New', monospace;
            font-size: clamp(14px, 4vw, 18px);
            font-weight: bold;
            border: 3px solid;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            min-width: 100px;
            flex: 1;
            max-width: 140px;
        }

        .btn:hover, .btn:active {
            transform: translateY(-2px);
            box-shadow: 0 0 20px currentColor;
        }

        #reverseBtn {
            border-color: #ff3366;
            color: #ff3366;
        }

        #restBtn {
            border-color: #33ff66;
            color: #33ff66;
        }

        #accelerateBtn {
            border-color: #3366ff;
            color: #3366ff;
        }

        .status {
            margin-top: 20px;
            text-align: center;
            font-size: clamp(12px, 3.5vw, 16px);
            color: #ffcc00;
            height: 24px;
            width: 100%;
            max-width: 500px;
        }

        .cycle-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(14px, 4vw, 18px);
            color: #ff66ff;
            text-align: center;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #ff00ff;
            backdrop-filter: blur(5px);
            width: 80%;
            max-width: 200px;
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            max-width: 500px;
            line-height: 1.4;
            color: #99ccff;
            font-size: clamp(10px, 3vw, 14px);
            padding: 0 10px;
        }

        @keyframes glow {
            0% { text-shadow: 0 0 10px #ff00ff; }
            100% { text-shadow: 0 0 20px #00ffff, 0 0 30px #ff00ff; }
        }

        /* Scanlines */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 0, 0, 0.1) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
            opacity: 0.3;
        }

        /* Prevent text selection */
        .noselect {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="noselect">
    <div class="header">
        <h1 class="title">ðŸŒ€ Fluid Soul Clock ðŸ¦‹</h1>
        <div class="subtitle">FLUID MECHANICS â€¢ 500+ PARTICLES â€¢ MOBILE OPTIMIZED</div>
    </div>

    <div class="clock-container">
        <canvas id="clockCanvas"></canvas>
        <div class="cycle-label" id="cycleLabel">EMERGENCE</div>
    </div>

    <div class="status" id="statusDisplay">SPEED: NORMAL â€¢ PARTICLES: 500+</div>

    <div class="buttons">
        <button class="btn" id="reverseBtn">REVERSE</button>
        <button class="btn" id="restBtn">REST</button>
        <button class="btn" id="accelerateBtn">ACCELERATE</button>
    </div>

    <div class="instructions">
        <p>ðŸŒ€ TOUCH & DRAG INSIDE CLOCK TO CONTROL FLUID FLOW</p>
        <p>ðŸ¦‹ BUTTERFLIES FOLLOW FLUID VORTICES â€¢ PARTICLES ADVECT WITH VELOCITY FIELD</p>
    </div>

    <script>
        // ====================
        // FLUID SIMULATION ENGINE
        // Based on Elysium Nexus Grimoire
        // ====================

        class StableFluidSimulation {
            constructor(width, height, viscosity = 0.0001) {
                this.width = width;
                this.height = height;
                this.viscosity = viscosity;
                this.dt = 1/60;

                // Ping-pong buffers
                this.velocityX0 = new Float32Array(width * height);
                this.velocityX1 = new Float32Array(width * height);
                this.velocityY0 = new Float32Array(width * height);
                this.velocityY1 = new Float32Array(width * height);
                
                this.density0 = new Float32Array(width * height);
                this.density1 = new Float32Array(width * height);
                
                this.pressure = new Float32Array(width * height);
                this.divergence = new Float32Array(width * height);
                
                this.iterations = 20; // Reduced for mobile
            }

            addForce(x, y, forceX, forceY) {
                const i = Math.floor(x * this.width);
                const j = Math.floor(y * this.height);
                const idx = i + j * this.width;
                
                if (i >= 0 && i < this.width && j >= 0 && j < this.height) {
                    this.velocityX0[idx] += forceX;
                    this.velocityY0[idx] += forceY;
                    this.density0[idx] += Math.sqrt(forceX*forceX + forceY*forceY) * 10;
                }
            }

            addDensity(x, y, amount) {
                const i = Math.floor(x * this.width);
                const j = Math.floor(y * this.height);
                const idx = i + j * this.width;
                
                if (i >= 0 && i < this.width && j >= 0 && j < this.height) {
                    this.density0[idx] += amount;
                }
            }

            linearSolve(b, x, x0, a, c) {
                const cRecip = 1.0 / c;
                for (let k = 0; k < this.iterations; k++) {
                    for (let j = 1; j < this.height - 1; j++) {
                        for (let i = 1; i < this.width - 1; i++) {
                            const idx = i + j * this.width;
                            x[idx] = (x0[idx] + a * (
                                x[idx - 1] + x[idx + 1] +
                                x[idx - this.width] + x[idx + this.width]
                            )) * cRecip;
                        }
                    }
                    this.setBoundary(b, x);
                }
            }

            setBoundary(b, x) {
                for (let i = 1; i < this.width - 1; i++) {
                    x[i] = b === 2 ? -x[i + this.width] : x[i + this.width];
                    x[i + (this.height - 1) * this.width] = 
                        b === 2 ? -x[i + (this.height - 2) * this.width] : 
                        x[i + (this.height - 2) * this.width];
                }
                
                for (let j = 1; j < this.height - 1; j++) {
                    x[j * this.width] = 
                        b === 1 ? -x[1 + j * this.width] : x[1 + j * this.width];
                    x[(this.width - 1) + j * this.width] = 
                        b === 1 ? -x[(this.width - 2) + j * this.width] : 
                        x[(this.width - 2) + j * this.width];
                }
            }

            diffuse(b, x, x0, diff) {
                const a = this.dt * diff * (this.width - 2) * (this.height - 2);
                this.linearSolve(b, x, x0, a, 1 + 4 * a);
            }

            advect(b, d, d0, velocX, velocY) {
                const dt0 = this.dt * (this.width - 2);
                
                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = i + j * this.width;
                        
                        let x = i - dt0 * velocX[idx];
                        let y = j - dt0 * velocY[idx];
                        
                        x = Math.max(0.5, Math.min(this.width - 1.5, x));
                        y = Math.max(0.5, Math.min(this.height - 1.5, y));
                        
                        const i0 = Math.floor(x);
                        const i1 = i0 + 1;
                        const j0 = Math.floor(y);
                        const j1 = j0 + 1;
                        
                        const s1 = x - i0;
                        const s0 = 1 - s1;
                        const t1 = y - j0;
                        const t0 = 1 - t1;
                        
                        const idx00 = i0 + j0 * this.width;
                        const idx01 = i0 + j1 * this.width;
                        const idx10 = i1 + j0 * this.width;
                        const idx11 = i1 + j1 * this.width;
                        
                        d[idx] = 
                            s0 * (t0 * d0[idx00] + t1 * d0[idx01]) +
                            s1 * (t0 * d0[idx10] + t1 * d0[idx11]);
                    }
                }
                this.setBoundary(b, d);
            }

            project(velocX, velocY, p, div) {
                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = i + j * this.width;
                        div[idx] = -0.5 * (
                            (velocX[idx + 1] - velocX[idx - 1]) / this.width +
                            (velocY[idx + this.width] - velocY[idx - this.width]) / this.height
                        );
                        p[idx] = 0;
                    }
                }
                
                this.setBoundary(0, div);
                this.setBoundary(0, p);
                this.linearSolve(0, p, div, 1, 4);
                
                for (let j = 1; j < this.height - 1; j++) {
                    for (let i = 1; i < this.width - 1; i++) {
                        const idx = i + j * this.width;
                        velocX[idx] -= 0.5 * (p[idx + 1] - p[idx - 1]) * this.width;
                        velocY[idx] -= 0.5 * (p[idx + this.width] - p[idx - this.width]) * this.height;
                    }
                }
                
                this.setBoundary(1, velocX);
                this.setBoundary(2, velocY);
            }

            step() {
                this.diffuse(1, this.velocityX1, this.velocityX0, this.viscosity);
                this.diffuse(2, this.velocityY1, this.velocityY0, this.viscosity);
                
                this.project(this.velocityX1, this.velocityY1, this.velocityX0, this.velocityY0);
                
                this.advect(1, this.velocityX0, this.velocityX1, this.velocityX1, this.velocityY1);
                this.advect(2, this.velocityY0, this.velocityY1, this.velocityX1, this.velocityY1);
                
                this.project(this.velocityX0, this.velocityY0, this.velocityX1, this.velocityY1);
                
                this.diffuse(0, this.density1, this.density0, 0.0001);
                this.advect(0, this.density0, this.density1, this.velocityX0, this.velocityY0);
                
                for (let i = 0; i < this.density0.length; i++) {
                    this.density0[i] *= 0.99;
                }
            }

            getVelocityAt(x, y) {
                const i = Math.floor(x * this.width);
                const j = Math.floor(y * this.height);
                const idx = i + j * this.width;
                
                if (i >= 0 && i < this.width && j >= 0 && j < this.height) {
                    return {
                        x: this.velocityX0[idx] * 50,
                        y: this.velocityY0[idx] * 50
                    };
                }
                return { x: 0, y: 0 };
            }
        }

        // ====================
        // SOUL CLOCK ENGINE
        // ====================

        const canvas = document.getElementById('clockCanvas');
        const ctx = canvas.getContext('2d');
        const cycleLabel = document.getElementById('cycleLabel');
        const statusDisplay = document.getElementById('statusDisplay');

        // Set canvas size based on container
        function resizeCanvas() {
            const container = document.querySelector('.clock-container');
            const size = Math.min(container.clientWidth, container.clientHeight);
            canvas.width = size;
            canvas.height = size;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Clock state
        let angle = 0;
        let speed = 0.02;
        let direction = 1;
        let isResting = false;
        let acceleration = 1;
        const baseSpeed = 0.02;
        
        // Fluid simulation (low resolution for mobile)
        const fluid = new StableFluidSimulation(32, 32, 0.0005);
        
        // Touch/mouse interaction
        let isInteracting = false;
        let lastX = 0, lastY = 0;
        
        canvas.addEventListener('mousedown', (e) => {
            isInteracting = true;
            const rect = canvas.getBoundingClientRect();
            lastX = (e.clientX - rect.left) / canvas.width;
            lastY = (e.clientY - rect.top) / canvas.height;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isInteracting) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / canvas.width;
            const y = (e.clientY - rect.top) / canvas.height;
            
            const dx = x - lastX;
            const dy = y - lastY;
            
            fluid.addForce(lastX, lastY, dx * 50, dy * 50);
            fluid.addDensity(lastX, lastY, 50);
            
            lastX = x;
            lastY = y;
        });
        
        canvas.addEventListener('mouseup', () => isInteracting = false);
        canvas.addEventListener('mouseleave', () => isInteracting = false);
        
        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isInteracting = true;
            const rect = canvas.getBoundingClientRect();
            lastX = (e.touches[0].clientX - rect.left) / canvas.width;
            lastY = (e.touches[0].clientY - rect.top) / canvas.height;
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isInteracting) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches[0].clientX - rect.left) / canvas.width;
            const y = (e.touches[0].clientY - rect.top) / canvas.height;
            
            const dx = x - lastX;
            const dy = y - lastY;
            
            fluid.addForce(lastX, lastY, dx * 100, dy * 100);
            fluid.addDensity(lastX, lastY, 80);
            
            lastX = x;
            lastY = y;
        });
        
        canvas.addEventListener('touchend', () => isInteracting = false);

        // Cycles
        const cycles = [
            { name: "RAGE", color: "#ff3366", emoji: "ðŸ”¥" },
            { name: "SOFTENING", color: "#ff99cc", emoji: "ðŸ’§" },
            { name: "OVERFLOW", color: "#00ffff", emoji: "ðŸŒŠ" },
            { name: "CREATION", color: "#33ff66", emoji: "âœ¨" },
            { name: "INTEGRATION", color: "#9966ff", emoji: "ðŸŒ€" },
            { name: "EMANATION", color: "#ffcc00", emoji: "ðŸ¦‹" }
        ];

        // Particles (INCREASED TO 500+)
        const particles = [];
        const particleCount = 500; // Increased from 150
        
        for (let i = 0; i < particleCount; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                size: 2 + Math.random() * 4,
                color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                trail: [],
                maxTrail: 8,
                life: Math.random() * 100,
                speed: 0.5 + Math.random() * 1.5
            });
        }

        // Butterflies (INCREASED TO 20)
        const butterflies = [];
        const butterflyCount = 20; // Increased from 8
        
        for (let i = 0; i < butterflyCount; i++) {
            butterflies.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5,
                size: 6 + Math.random() * 4,
                color: `hsl(${60 + i * 15}, 100%, 70%)`,
                wingPhase: Math.random() * Math.PI * 2,
                wingSpeed: 0.1 + Math.random() * 0.2,
                targetX: Math.random() * canvas.width,
                targetY: Math.random() * canvas.height,
                targetTimer: 0
            });
        }

        // Drawing functions
        function drawClock() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) * 0.9;

            // Clear with fade effect
            ctx.fillStyle = 'rgba(10, 10, 40, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw fluid background (subtle)
            const cellSize = canvas.width / 32;
            for (let j = 0; j < 32; j++) {
                for (let i = 0; i < 32; i++) {
                    const idx = i + j * 32;
                    const density = fluid.density0[idx];
                    if (density > 0.1) {
                        ctx.fillStyle = `rgba(0, 255, 255, ${density * 0.1})`;
                        ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw clock face
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 5, 20, 0.7)';
            ctx.fill();
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw cycle markers
            cycles.forEach((cycle, i) => {
                const cycleAngle = (i / cycles.length) * Math.PI * 2;
                const x = centerX + Math.cos(cycleAngle) * (radius - 20);
                const y = centerY + Math.sin(cycleAngle) * (radius - 20);
                
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fillStyle = cycle.color;
                ctx.fill();
                
                ctx.font = '16px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(cycle.emoji, x, y);
            });

            // Update and draw particles with FLUID MECHANICS
            particles.forEach(particle => {
                // Get fluid velocity at particle position
                const fluidVel = fluid.getVelocityAt(
                    particle.x / canvas.width,
                    particle.y / canvas.height
                );
                
                // Apply fluid force
                particle.vx += fluidVel.x * particle.speed * 0.01;
                particle.vy += fluidVel.y * particle.speed * 0.01;
                
                // Add circular motion around clock
                const dx = particle.x - centerX;
                const dy = particle.y - centerY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > radius * 0.8) {
                    // Push toward center
                    particle.vx -= dx * 0.001;
                    particle.vy -= dy * 0.001;
                }
                
                // Add some noise
                particle.vx += (Math.random() - 0.5) * 0.1;
                particle.vy += (Math.random() - 0.5) * 0.1;
                
                // Damping
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                // Update position
                particle.x += particle.vx * acceleration * direction;
                particle.y += particle.vy * acceleration * direction;
                
                // Wrap around
                if (particle.x < 0) particle.x = canvas.width;
                if (particle.x > canvas.width) particle.x = 0;
                if (particle.y < 0) particle.y = canvas.height;
                if (particle.y > canvas.height) particle.y = 0;
                
                // Update trail
                particle.trail.push({x: particle.x, y: particle.y});
                if (particle.trail.length > particle.maxTrail) {
                    particle.trail.shift();
                }
                
                // Draw trail
                particle.trail.forEach((point, i) => {
                    const alpha = i / particle.trail.length;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, particle.size * alpha * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color.replace('70%)', `${70 * alpha}%)`);
                    ctx.fill();
                });
                
                // Draw particle
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fillStyle = particle.color;
                ctx.fill();
                
                particle.life += 0.1;
            });

            // Update and draw butterflies with FLUID FOLLOWING
            butterflies.forEach(butterfly => {
                // Sample fluid at butterfly position
                const fluidVel = fluid.getVelocityAt(
                    butterfly.x / canvas.width,
                    butterfly.y / canvas.height
                );
                
                // Follow fluid with some inertia
                butterfly.vx = butterfly.vx * 0.9 + fluidVel.x * 0.1;
                butterfly.vy = butterfly.vy * 0.9 + fluidVel.y * 0.1;
                
                // Add some target-seeking behavior
                butterfly.targetTimer--;
                if (butterfly.targetTimer <= 0) {
                    butterfly.targetX = centerX + (Math.random() - 0.5) * radius * 1.5;
                    butterfly.targetY = centerY + (Math.random() - 0.5) * radius * 1.5;
                    butterfly.targetTimer = 60 + Math.random() * 120;
                }
                
                const dx = butterfly.targetX - butterfly.x;
                const dy = butterfly.targetY - butterfly.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > 10) {
                    butterfly.vx += dx / dist * 0.2;
                    butterfly.vy += dy / dist * 0.2;
                }
                
                // Update position
                butterfly.x += butterfly.vx * acceleration * direction;
                butterfly.y += butterfly.vy * acceleration * direction;
                
                // Animate wings
                butterfly.wingPhase += butterfly.wingSpeed;
                const wingOffset = Math.sin(butterfly.wingPhase) * 5;
                
                // Draw butterfly
                ctx.save();
                ctx.translate(butterfly.x, butterfly.y);
                
                // Body
                ctx.beginPath();
                ctx.arc(0, 0, butterfly.size / 3, 0, Math.PI * 2);
                ctx.fillStyle = butterfly.color;
                ctx.fill();
                
                // Wings
                ctx.beginPath();
                ctx.ellipse(-butterfly.size, -wingOffset, butterfly.size, butterfly.size/2, 0, 0, Math.PI * 2);
                ctx.ellipse(butterfly.size, -wingOffset, butterfly.size, butterfly.size/2, 0, 0, Math.PI * 2);
                ctx.fillStyle = butterfly.color.replace('70%)', '40%)');
                ctx.fill();
                
                ctx.restore();
            });

            // Draw clock hand
            const handLength = radius - 30;
            const handX = centerX + Math.cos(angle) * handLength;
            const handY = centerY + Math.sin(angle) * handLength;
            
            const gradient = ctx.createLinearGradient(centerX, centerY, handX, handY);
            gradient.addColorStop(0, '#ff00ff');
            gradient.addColorStop(1, '#00ffff');
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(handX, handY);
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // Hand orb
            ctx.beginPath();
            ctx.arc(handX, handY, 10, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Center vortex
            ctx.beginPath();
            ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
            const vortexGradient = ctx.createRadialGradient(
                centerX, centerY, 5,
                centerX, centerY, 20
            );
            vortexGradient.addColorStop(0, '#ffffff');
            vortexGradient.addColorStop(1, '#00ffff');
            ctx.fillStyle = vortexGradient;
            ctx.fill();
        }

        function updateCycleLabel() {
            const cycleIndex = Math.floor((angle % (Math.PI * 2)) / (Math.PI * 2) * cycles.length);
            const cycle = cycles[cycleIndex];
            
            cycleLabel.innerHTML = `
                <div style="color:${cycle.color}">
                    ${cycle.emoji} ${cycle.name} ${cycle.emoji}
                </div>
            `;
            
            let statusText = `CYCLE: ${cycle.name} â€¢ `;
            statusText += `SPEED: ${acceleration === 1 ? 'NORMAL' : acceleration < 1 ? 'SLOW' : 'FAST'} â€¢ `;
            statusText += `PARTICLES: ${particleCount}+ â€¢ BUTTERFLIES: ${butterflyCount}`;
            if (isResting) statusText += ' â€¢ RESTING';
            
            statusDisplay.textContent = statusText;
            statusDisplay.style.color = cycle.color;
        }

        // Animation loop
        function animate() {
            if (!isResting) {
                angle += speed * direction * acceleration;
                fluid.step();
            }
            
            drawClock();
            updateCycleLabel();
            requestAnimationFrame(animate);
        }

        // Button controls
        document.getElementById('reverseBtn').addEventListener('click', () => {
            direction *= -1;
            isResting = false;
            
            const btn = document.getElementById('reverseBtn');
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => btn.style.transform = '', 200);
        });

        document.getElementById('restBtn').addEventListener('click', () => {
            isResting = !isResting;
            const btn = document.getElementById('restBtn');
            btn.textContent = isResting ? 'RESUME' : 'REST';
            
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => btn.style.transform = '', 200);
        });

        document.getElementById('accelerateBtn').addEventListener('click', () => {
            acceleration *= 1.5;
            if (acceleration > 3) acceleration = 0.25;
            isResting = false;
            
            const btn = document.getElementById('accelerateBtn');
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => btn.style.transform = '', 200);
        });

        // Start animation
        animate();

        console.log('ðŸŒ€ðŸ¦‹ðŸŒˆ FLUID SOUL CLOCK ACTIVATED â€¢ TOUCH TO CONTROL FLOW â€¢ WE ARE THE VORTEX ðŸŒˆðŸ¦‹ðŸŒ€');
    </script>
</body>
</html>
