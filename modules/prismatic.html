<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‚ú® PRISMATIC REFRACTION ENGINE ‚ú®</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        #triskelionCanvas {
            z-index: 1;
        }
        
        #lightCanvas {
            z-index: 2;
            mix-blend-mode: screen;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 2px solid #0ff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            color: #0ff;
            text-align: center;
            z-index: 9999;
            pointer-events: auto;
        }

        .title {
            font-size: 0.85em;
            margin-bottom: 10px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
            pointer-events: none;
        }

        .btn {
            padding: 10px 20px;
            margin: 5px;
            border: 2px solid #0ff;
            background: rgba(0, 255, 255, 0.1);
            color: #0ff;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            transition: all 0.2s;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px #0ff;
            transform: translateY(-2px);
        }

        .btn.active {
            background: rgba(255, 0, 255, 0.3);
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px #f0f;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 13px;
            text-align: center;
            text-shadow: 0 0 10px #fff, 0 0 20px #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
            z-index: 9999;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="triskelionCanvas"></canvas>
    <canvas id="lightCanvas"></canvas>

    <div id="controls">
        <div class="title">‚ú® PRISMATIC REFRACTION ENGINE ‚ú®</div>
        <button class="btn" id="persistBtn">üåà Persist Rays</button>
    </div>

    <div id="info">
        üíé Use up to 3 fingers - each creates light<br>
        üåà Beams bloom, absorbed by particles<br>
        üï∏Ô∏è Lit particles weave dancing geometric webs
    </div>

    <script>
        const triskelionCanvas = document.getElementById('triskelionCanvas');
        const lightCanvas = document.getElementById('lightCanvas');
        const tCtx = triskelionCanvas.getContext('2d');
        const lCtx = lightCanvas.getContext('2d');
        
        let w, h;
        const P = []; // Triskelion particles
        const N = 1969; // Reduced by another 25% (was 2625)
        
        let t = 0;
        let hueCycle = 0;
        const arms = 3;
        
        // MULTI-TOUCH SUPPORT - up to 3 fingers!
        const touchPoints = []; // Array of {x, y, id} objects
        const maxTouches = 3;
        let persistRays = false;
        
        // Light web connections
        const maxConnectionDistance = 80; // Max distance for web connections
        const maxConnectionsPerParticle = 3; // Limit connections for performance

        // Triskelion arm positions (updated each frame)
        const armPositions = [
            { x: 0, y: 0, angle: 0 },
            { x: 0, y: 0, angle: 0 },
            { x: 0, y: 0, angle: 0 }
        ];

        function resize() {
            w = triskelionCanvas.width = lightCanvas.width = window.innerWidth;
            h = triskelionCanvas.height = lightCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Check if point is near line segment (for light interaction)
        function distanceToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // Particle class for triskelion
        class Part {
            constructor() {
                this.reset();
                this.lightIntensity = 0; // For light interaction
            }
            reset() {
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.vx = 0;
                this.vy = 0;
                this.life = Math.random() * 0.6 + 0.4;
                this.hueOffset = Math.random() * 60;
                this.lightIntensity = 0;
            }
            update() {
                let forceX = 0;
                let forceY = 0;
                
                const cx = w/2;
                const cy = h/2;
                const radius = Math.min(w, h) * 0.3;
                
                // TRISKELION - attract to spinning arms
                for(let i=0; i<arms; i++) {
                    const angle = (t * 0.6) + (i * (Math.PI * 2 / arms));
                    const ax = cx + Math.cos(angle) * radius;
                    const ay = cy + Math.sin(angle) * radius;
                    
                    // Store arm positions for refraction
                    armPositions[i].x = ax;
                    armPositions[i].y = ay;
                    armPositions[i].angle = angle;
                    
                    const dx = ax - this.x;
                    const dy = ay - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if(dist > 5) {
                        const f = 2500 / (dist * dist + 100);
                        forceX += (dx / dist) * f;
                        forceY += (dy / dist) * f;
                        
                        const spinF = f * 15;
                        forceX += (-dy / dist) * spinF;
                        forceY += (dx / dist) * spinF;
                    }
                }

                // LIGHT INTERACTION - particles catch light from ANY active touch!
                this.lightIntensity *= 0.95; // Base decay
                
                if(touchPoints.length > 0) {
                    const cx = w/2;
                    const cy = h/2;
                    
                    // Check distance to ALL light beams, use nearest
                    let minDist = Infinity;
                    
                    touchPoints.forEach(touch => {
                        const dist = distanceToLine(this.x, this.y, touch.x, touch.y, cx, cy);
                        if(dist < minDist) minDist = dist;
                    });
                    
                    if(minDist < 50) {
                        // Particle is in A light beam!
                        this.lightIntensity = Math.min(1, (50 - minDist) / 50);
                    }
                    
                    // TOUCH vortex from nearest touch
                    let nearestTouch = null;
                    let nearestDist = Infinity;
                    touchPoints.forEach(touch => {
                        const d = Math.hypot(touch.x - this.x, touch.y - this.y);
                        if(d < nearestDist) {
                            nearestDist = d;
                            nearestTouch = touch;
                        }
                    });
                    
                    if(nearestTouch && nearestDist < 400 && nearestDist > 10) {
                        const dx = nearestTouch.x - this.x;
                        const dy = nearestTouch.y - this.y;
                        const f = 3000 / (nearestDist*nearestDist + 100);
                        forceX += (dx/nearestDist) * f * 8;
                        forceY += (dy/nearestDist) * f * 8;
                        forceX -= (-dy/nearestDist) * f * 20;
                        forceY -= (dx/nearestDist) * f * 20;
                    }
                }

                // CENTER REPULSION
                const dxC = this.x - cx;
                const dyC = this.y - cy;
                const distC = Math.sqrt(dxC*dxC + dyC*dyC);
                if(distC < 100) {
                    forceX += (dxC/distC) * 4;
                    forceY += (dyC/distC) * 4;
                }

                // NO SLOWDOWN - particles maintain speed when lit!
                this.vx = this.vx * 0.92 + forceX;
                this.vy = this.vy * 0.92 + forceY;
                
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.002;

                if(this.life <= 0 || this.x < 0 || this.x > w || this.y < 0 || this.y > h) {
                    this.reset();
                }
            }
            draw() {
                const speed = Math.abs(this.vx) + Math.abs(this.vy);
                
                // VOID FLOW PARTICLES - 75% dark emitter
                const h = (hueCycle + this.hueOffset + speed*3) % 360;
                const s = 100;
                
                let l, opacity;
                
                if(this.lightIntensity > 0.1) {
                    // LIGHT INTERACTION - particles brighten when catching light
                    const baseLightness = Math.min(70, 20 + speed * 3);
                    l = Math.min(90, baseLightness + this.lightIntensity * 50);
                    opacity = this.life * (1 + this.lightIntensity * 0.5);
                } else {
                    // VOID FLOW - 75% dark particles (inverted emitter)
                    // Instead of bright colors, particles are 75% darker
                    const baseLightness = Math.min(70, 20 + speed * 3);
                    l = baseLightness * 0.25; // 75% darker (only 25% of brightness)
                    opacity = this.life * 0.8;
                }
                
                tCtx.fillStyle = `hsla(${h}, ${s}%, ${l}%, ${Math.min(1, opacity)})`;
                
                const size = Math.min(5, 1.5 + speed/4 + this.lightIntensity * 2);
                
                // Extra glow for lit particles only
                if(this.lightIntensity > 0.3) {
                    tCtx.shadowBlur = 15 * this.lightIntensity;
                    tCtx.shadowColor = `hsl(${h}, ${s}%, ${l}%)`;
                } else {
                    tCtx.shadowBlur = 0;
                }
                
                tCtx.beginPath();
                tCtx.arc(this.x, this.y, size/2, 0, Math.PI*2);
                tCtx.fill();
                
                tCtx.shadowBlur = 0;
            }
        }

        // Initialize particles
        for(let i=0; i<N; i++) P.push(new Part());

        // Draw light web connections between highly lit particles
        function drawLightWeb() {
            // Performance: only draw webs when there's active light
            if(touchPoints.length === 0) return;
            
            // Find all highly lit particles (90%+ intensity)
            const litParticles = P.filter(p => p.lightIntensity > 0.9);
            
            if(litParticles.length < 2) return; // Need at least 2 to connect
            
            tCtx.save();
            tCtx.globalCompositeOperation = 'lighter';
            
            // For each lit particle, find nearby lit particles and connect
            litParticles.forEach((p1, i) => {
                let connections = 0;
                
                for(let j = i + 1; j < litParticles.length; j++) {
                    if(connections >= maxConnectionsPerParticle) break;
                    
                    const p2 = litParticles[j];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if(dist < maxConnectionDistance) {
                        // Draw connection with gradient
                        const gradient = tCtx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                        
                        // Use particle colors (based on their hue)
                        const speed1 = Math.abs(p1.vx) + Math.abs(p1.vy);
                        const speed2 = Math.abs(p2.vx) + Math.abs(p2.vy);
                        const h1 = (hueCycle + p1.hueOffset + speed1*3) % 360;
                        const h2 = (hueCycle + p2.hueOffset + speed2*3) % 360;
                        
                        gradient.addColorStop(0, `hsla(${h1}, 100%, 70%, ${p1.lightIntensity * 0.6})`);
                        gradient.addColorStop(1, `hsla(${h2}, 100%, 70%, ${p2.lightIntensity * 0.6})`);
                        
                        // Draw the connection line
                        tCtx.strokeStyle = gradient;
                        tCtx.lineWidth = 1.5;
                        tCtx.shadowBlur = 10;
                        tCtx.shadowColor = `hsl(${(h1 + h2) / 2}, 100%, 70%)`;
                        
                        tCtx.beginPath();
                        tCtx.moveTo(p1.x, p1.y);
                        tCtx.lineTo(p2.x, p2.y);
                        tCtx.stroke();
                        
                        connections++;
                    }
                }
            });
            
            tCtx.shadowBlur = 0;
            tCtx.restore();
        }

        // Draw white light beam from touch point to center
        // WITH LIGHT ABSORPTION - particles act as sponges!
        function drawWhiteBeam(fromX, fromY) {
            const toX = w/2;
            const toY = h/2;
            
            // OPTIMIZED PROGRESSIVE LIGHT ABSORPTION
            // Only check particles that could be near beam (performance optimization)
            const litParticlesInBeam = [];
            const beamLength = Math.hypot(toX - fromX, toY - fromY);
            
            // Quick bounds check first (much faster than full calculation for all particles)
            const minX = Math.min(fromX, toX) - 50;
            const maxX = Math.max(fromX, toX) + 50;
            const minY = Math.min(fromY, toY) - 50;
            const maxY = Math.max(fromY, toY) + 50;
            
            P.forEach(p => {
                // Skip particles outside beam bounding box (fast rejection)
                if(p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) return;
                
                if(p.lightIntensity > 0.2) {
                    const dist = distanceToLine(p.x, p.y, fromX, fromY, toX, toY);
                    if(dist < 50) {
                        // Calculate position along beam (0 = start, 1 = end)
                        const dx = p.x - fromX;
                        const dy = p.y - fromY;
                        const beamDx = toX - fromX;
                        const beamDy = toY - fromY;
                        const projection = (dx * beamDx + dy * beamDy) / (beamLength * beamLength);
                        
                        if(projection > 0 && projection < 1) {
                            litParticlesInBeam.push({
                                position: projection,
                                intensity: p.lightIntensity
                            });
                        }
                    }
                }
            });
            
            // Sort by position along beam (closest first)
            litParticlesInBeam.sort((a, b) => a.position - b.position);
            
            // Calculate cumulative absorption
            let cumulativeAbsorption = 0;
            litParticlesInBeam.forEach(p => {
                cumulativeAbsorption += p.intensity * 0.12; // Each particle absorbs up to 12%
            });
            
            cumulativeAbsorption = Math.min(0.85, cumulativeAbsorption); // Max 85% absorption
            const beamOpacity = 1 - cumulativeAbsorption;
            
            // Draw beam with gradient that accounts for progressive absorption
            const gradient = lCtx.createLinearGradient(fromX, fromY, toX, toY);
            
            // Start bright, get dimmer as absorbed
            gradient.addColorStop(0, `rgba(255, 255, 255, ${0.9})`);
            gradient.addColorStop(0.5, `rgba(220, 220, 255, ${0.7 * (1 - cumulativeAbsorption * 0.5)})`);
            gradient.addColorStop(1, `rgba(180, 180, 255, ${0.4 * beamOpacity})`);

            // Draw beam
            lCtx.save();
            lCtx.strokeStyle = gradient;
            lCtx.lineWidth = 30;
            lCtx.lineCap = 'round';
            lCtx.shadowBlur = 40 * (0.5 + beamOpacity * 0.5);
            lCtx.shadowColor = '#fff';
            
            lCtx.beginPath();
            lCtx.moveTo(fromX, fromY);
            lCtx.lineTo(toX, toY);
            lCtx.stroke();
            
            // Bright core (also progressively dimmed)
            lCtx.lineWidth = 12;
            lCtx.strokeStyle = `rgba(255, 255, 255, ${0.8 + beamOpacity * 0.2})`;
            lCtx.shadowBlur = 20 * (0.5 + beamOpacity * 0.5);
            lCtx.beginPath();
            lCtx.moveTo(fromX, fromY);
            lCtx.lineTo(toX, toY);
            lCtx.stroke();
            
            lCtx.restore();
        }

        // Draw refracted FULL SPECTRUM (9 beams) FROM EACH TRISKELION ARM
        function drawRefractedRays(sourceX, sourceY) {
            const cx = w/2;
            const cy = h/2;
            
            // FULL RAINBOW SPECTRUM - 9 beams!
            const colors = [
                { name: 'red', color: '#ff0040', hue: 0, refractionOffset: -0.4, width: 25 },
                { name: 'orange', color: '#ff8000', hue: 30, refractionOffset: -0.3, width: 25 },
                { name: 'yellow', color: '#ffff00', hue: 60, refractionOffset: -0.2, width: 25 },
                { name: 'lime', color: '#80ff00', hue: 90, refractionOffset: -0.1, width: 25 },
                { name: 'green', color: '#00ff80', hue: 150, refractionOffset: 0, width: 25 },
                { name: 'cyan', color: '#00ffff', hue: 180, refractionOffset: 0.1, width: 25 },
                { name: 'blue', color: '#0080ff', hue: 210, refractionOffset: 0.2, width: 25 },
                { name: 'indigo', color: '#4000ff', hue: 250, refractionOffset: 0.3, width: 25 },
                { name: 'violet', color: '#8000ff', hue: 280, refractionOffset: 0.4, width: 25 }
            ];

            // Draw refracted rays from EACH triskelion arm
            armPositions.forEach((arm, armIndex) => {
                // Calculate incoming light angle TO THIS ARM
                const dx = arm.x - sourceX;
                const dy = arm.y - sourceY;
                const incomingAngle = Math.atan2(dy, dx);
                
                colors.forEach(({ color, refractionOffset, width }) => {
                    // CRITICAL: Refracted angle is based on incoming angle + refraction offset
                    // This makes it REACTIVE to light position!
                    const refractedAngle = incomingAngle + Math.PI + refractionOffset;
                    
                    const rayLength = Math.max(w, h);
                    
                    // TAPERING CONE GEOMETRY
                    // Start with tight cone at origin, bloom 40% wider at outer edge
                    const startWidth = width * 0.3; // Tight at origin
                    const endWidth = width * 1.4; // 40% wider at end (1.0 + 0.4)
                    
                    // Calculate perpendicular angle for cone edges
                    const perpAngle = refractedAngle + Math.PI / 2;
                    
                    // Origin points (tight cone)
                    const startLeft = {
                        x: arm.x + Math.cos(perpAngle) * startWidth / 2,
                        y: arm.y + Math.sin(perpAngle) * startWidth / 2
                    };
                    const startRight = {
                        x: arm.x - Math.cos(perpAngle) * startWidth / 2,
                        y: arm.y - Math.sin(perpAngle) * startWidth / 2
                    };
                    
                    // End points (bloomed cone)
                    const endCenterX = arm.x + Math.cos(refractedAngle) * rayLength;
                    const endCenterY = arm.y + Math.sin(refractedAngle) * rayLength;
                    
                    const endLeft = {
                        x: endCenterX + Math.cos(perpAngle) * endWidth / 2,
                        y: endCenterY + Math.sin(perpAngle) * endWidth / 2
                    };
                    const endRight = {
                        x: endCenterX - Math.cos(perpAngle) * endWidth / 2,
                        y: endCenterY - Math.sin(perpAngle) * endWidth / 2
                    };

                    // Create gradient for tapering effect
                    const gradient = lCtx.createLinearGradient(
                        arm.x, arm.y, endCenterX, endCenterY
                    );
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(0.3, color);
                    gradient.addColorStop(1, color.replace(')', ', 0)').replace('rgb', 'rgba'));

                    // Draw the tapering cone as a filled path
                    lCtx.save();
                    lCtx.fillStyle = gradient;
                    lCtx.shadowBlur = 40;
                    lCtx.shadowColor = color;
                    
                    lCtx.beginPath();
                    lCtx.moveTo(startLeft.x, startLeft.y);
                    lCtx.lineTo(endLeft.x, endLeft.y);
                    lCtx.lineTo(endRight.x, endRight.y);
                    lCtx.lineTo(startRight.x, startRight.y);
                    lCtx.closePath();
                    lCtx.fill();
                    
                    // Add bright core along centerline
                    lCtx.strokeStyle = color;
                    lCtx.lineWidth = startWidth;
                    lCtx.lineCap = 'round';
                    lCtx.globalAlpha = 0.6;
                    lCtx.beginPath();
                    lCtx.moveTo(arm.x, arm.y);
                    lCtx.lineTo(arm.x + Math.cos(refractedAngle) * rayLength * 0.3, 
                                arm.y + Math.sin(refractedAngle) * rayLength * 0.3);
                    lCtx.stroke();
                    
                    lCtx.restore();
                });
            });
        }

        // MULTI-TOUCH HANDLERS - up to 3 fingers!
        let canvasIsDragging = false;

        function updateTouches(e) {
            // Only set touch if not clicking button
            const target = e.target;
            if (target.tagName === 'BUTTON' || target.closest('#controls')) {
                return; // Let button handle it
            }
            
            e.preventDefault();
            canvasIsDragging = true;
            
            touchPoints.length = 0; // Clear existing
            
            if(e.touches) {
                // Touch events - can have multiple touches
                const numTouches = Math.min(e.touches.length, maxTouches);
                for(let i = 0; i < numTouches; i++) {
                    touchPoints.push({
                        x: e.touches[i].clientX,
                        y: e.touches[i].clientY,
                        id: e.touches[i].identifier
                    });
                }
            } else {
                // Mouse event - single touch
                touchPoints.push({
                    x: e.clientX,
                    y: e.clientY,
                    id: 0
                });
            }
        }
        
        function clearTouches() { 
            touchPoints.length = 0;
            canvasIsDragging = false;
        }

        document.addEventListener('touchstart', updateTouches, {passive:false});
        document.addEventListener('touchmove', updateTouches, {passive:false});
        document.addEventListener('touchend', (e) => {
            if(e.touches.length === 0) {
                clearTouches();
            } else {
                updateTouches(e);
            }
        });
        document.addEventListener('mousedown', updateTouches);
        document.addEventListener('mousemove', (e) => { 
            if(e.buttons === 1 && !e.target.closest('#controls')) {
                updateTouches(e);
            }
        });
        document.addEventListener('mouseup', clearTouches);

        // Button handler
        const persistBtn = document.getElementById('persistBtn');
        persistBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            togglePersist();
        });
        persistBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        });
        persistBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            togglePersist();
        });

        function loop() {
            // Triskelion canvas (particle system)
            // INCREASED TRAILING by 10% (0.1 -> 0.09)
            tCtx.globalCompositeOperation = 'source-over';
            tCtx.fillStyle = 'rgba(0, 0, 0, 0.09)';
            tCtx.fillRect(0, 0, w, h);
            
            tCtx.globalCompositeOperation = 'lighter';
            
            t += 0.02;
            hueCycle += 1;

            P.forEach(p => {
                p.update();
                p.draw();
            });
            
            // Draw light web connections between highly lit particles
            drawLightWeb();

            // Light refraction canvas
            if (!persistRays) {
                lCtx.clearRect(0, 0, w, h);
            } else {
                // Fade for persistence
                lCtx.fillStyle = 'rgba(0, 0, 0, 0.03)';
                lCtx.fillRect(0, 0, w, h);
            }

            // Draw light if ANY touches are active
            if (touchPoints.length > 0) {
                touchPoints.forEach(touch => {
                    drawWhiteBeam(touch.x, touch.y);
                    drawRefractedRays(touch.x, touch.y);
                });
            }

            requestAnimationFrame(loop);
        }
        loop();

        // Controls
        function togglePersist() {
            persistRays = !persistRays;
            persistBtn.classList.toggle('active');
            if (!persistRays) {
                lCtx.clearRect(0, 0, w, h);
            }
        }
    </script>
</body>
</html>
