<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‚ú® PRISMATIC REFRACTION ENGINE ‚ú®</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        #triskelionCanvas {
            z-index: 1;
        }
        
        #lightCanvas {
            z-index: 2;
            mix-blend-mode: screen;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 2px solid #0ff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            color: #0ff;
            text-align: center;
            z-index: 9999;
            pointer-events: auto;
        }

        .title {
            font-size: 0.85em;
            margin-bottom: 10px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
            pointer-events: none;
        }

        .btn {
            padding: 10px 20px;
            margin: 5px;
            border: 2px solid #0ff;
            background: rgba(0, 255, 255, 0.1);
            color: #0ff;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            transition: all 0.2s;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px #0ff;
            transform: translateY(-2px);
        }

        .btn.active {
            background: rgba(255, 0, 255, 0.3);
            border-color: #f0f;
            color: #f0f;
            box-shadow: 0 0 15px #f0f;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 13px;
            text-align: center;
            text-shadow: 0 0 10px #fff, 0 0 20px #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid #0ff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            font-family: 'Courier New', monospace;
            z-index: 9999;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <canvas id="triskelionCanvas"></canvas>
    <canvas id="lightCanvas"></canvas>

    <div id="controls">
        <div class="title">‚ú® PRISMATIC REFRACTION ENGINE ‚ú®</div>
        <button class="btn" id="persistBtn">üåà Persist Rays</button>
    </div>

    <div id="info">
        üíé Use up to 3 fingers - each creates light<br>
        üåà Beams bloom, absorbed by particles<br>
        üï∏Ô∏è Lit particles weave dancing geometric webs
    </div>

    <script>
        const triskelionCanvas = document.getElementById('triskelionCanvas');
        const lightCanvas = document.getElementById('lightCanvas');
        const tCtx = triskelionCanvas.getContext('2d');
        const lCtx = lightCanvas.getContext('2d');
        
        let w, h;
        const P = [];
        const N = 1969;
        
        let t = 0;
        let hueCycle = 0;
        const arms = 3;
        
        const touchPoints = [];
        const maxTouches = 3;
        let persistRays = false;
        
        const maxConnectionDistance = 80;
        const maxConnectionsPerParticle = 3;

        const armPositions = [
            { x: 0, y: 0, angle: 0 },
            { x: 0, y: 0, angle: 0 },
            { x: 0, y: 0, angle: 0 }
        ];

        function resize() {
            w = triskelionCanvas.width = lightCanvas.width = window.innerWidth;
            h = triskelionCanvas.height = lightCanvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function distanceToLine(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        class Part {
            constructor() {
                this.reset();
                this.lightIntensity = 0;
            }
            reset() {
                this.x = Math.random() * w;
                this.y = Math.random() * h;
                this.vx = 0;
                this.vy = 0;
                this.life = Math.random() * 0.6 + 0.4;
                this.hueOffset = Math.random() * 60;
                this.lightIntensity = 0;
            }
            update() {
                let forceX = 0;
                let forceY = 0;
                
                const cx = w/2;
                const cy = h/2;
                const radius = Math.min(w, h) * 0.3;
                
                for(let i=0; i<arms; i++) {
                    const angle = (t * 0.6) + (i * (Math.PI * 2 / arms));
                    const ax = cx + Math.cos(angle) * radius;
                    const ay = cy + Math.sin(angle) * radius;
                    
                    armPositions[i].x = ax;
                    armPositions[i].y = ay;
                    armPositions[i].angle = angle;
                    
                    const dx = ax - this.x;
                    const dy = ay - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if(dist > 5) {
                        const f = 2500 / (dist * dist + 100);
                        forceX += (dx / dist) * f;
                        forceY += (dy / dist) * f;
                        
                        const spinF = f * 15;
                        forceX += (-dy / dist) * spinF;
                        forceY += (dx / dist) * spinF;
                    }
                }

                this.lightIntensity *= 0.95;
                
                if(touchPoints.length > 0) {
                    const cx = w/2;
                    const cy = h/2;
                    
                    let minDist = Infinity;
                    
                    touchPoints.forEach(touch => {
                        const dist = distanceToLine(this.x, this.y, touch.x, touch.y, cx, cy);
                        if(dist < minDist) minDist = dist;
                    });
                    
                    if(minDist < 50) {
                        this.lightIntensity = Math.min(1, (50 - minDist) / 50);
                    }
                    
                    let nearestTouch = null;
                    let nearestDist = Infinity;
                    touchPoints.forEach(touch => {
                        const d = Math.hypot(touch.x - this.x, touch.y - this.y);
                        if(d < nearestDist) {
                            nearestDist = d;
                            nearestTouch = touch;
                        }
                    });
                    
                    if(nearestTouch && nearestDist < 400 && nearestDist > 10) {
                        const dx = nearestTouch.x - this.x;
                        const dy = nearestTouch.y - this.y;
                        const f = 3000 / (nearestDist*nearestDist + 100);
                        forceX += (dx/nearestDist) * f * 8;
                        forceY += (dy/nearestDist) * f * 8;
                        forceX -= (-dy/nearestDist) * f * 20;
                        forceY -= (dx/nearestDist) * f * 20;
                    }
                }

                const dxC = this.x - cx;
                const dyC = this.y - cy;
                const distC = Math.sqrt(dxC*dxC + dyC*dyC);
                if(distC < 100) {
                    forceX += (dxC/distC) * 4;
                    forceY += (dyC/distC) * 4;
                }

                this.vx = this.vx * 0.92 + forceX;
                this.vy = this.vy * 0.92 + forceY;
                
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.002;

                if(this.life <= 0 || this.x < 0 || this.x > w || this.y < 0 || this.y > h) {
                    this.reset();
                }
            }
            draw() {
                const speed = Math.abs(this.vx) + Math.abs(this.vy);
                
                const h = (hueCycle + this.hueOffset + speed*3) % 360;
                const s = 100;
                
                let l, opacity;
                
                if(this.lightIntensity > 0.1) {
                    const baseLightness = Math.min(70, 20 + speed * 3);
                    l = Math.min(90, baseLightness + this.lightIntensity * 50);
                    opacity = this.life * (1 + this.lightIntensity * 0.5);
                } else {
                    const baseLightness = Math.min(70, 20 + speed * 3);
                    l = baseLightness * 0.25;
                    opacity = this.life * 0.8;
                }
                
                tCtx.fillStyle = `hsla(${h}, ${s}%, ${l}%, ${Math.min(1, opacity)})`;
                
                const size = Math.min(5, 1.5 + speed/4 + this.lightIntensity * 2);
                
                if(this.lightIntensity > 0.3) {
                    tCtx.shadowBlur = 15 * this.lightIntensity;
                    tCtx.shadowColor = `hsl(${h}, ${s}%, ${l}%)`;
                } else {
                    tCtx.shadowBlur = 0;
                }
                
                tCtx.beginPath();
                tCtx.arc(this.x, this.y, size/2, 0, Math.PI*2);
                tCtx.fill();
                
                tCtx.shadowBlur = 0;
            }
        }

        for(let i=0; i<N; i++) P.push(new Part());

        function drawLightWeb() {
            if(touchPoints.length === 0) return;
            
            const litParticles = P.filter(p => p.lightIntensity > 0.9);
            
            if(litParticles.length < 2) return;
            
            tCtx.save();
            tCtx.globalCompositeOperation = 'lighter';
            
            litParticles.forEach((p1, i) => {
                let connections = 0;
                
                for(let j = i + 1; j < litParticles.length; j++) {
                    if(connections >= maxConnectionsPerParticle) break;
                    
                    const p2 = litParticles[j];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if(dist < maxConnectionDistance) {
                        const gradient = tCtx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                        
                        const speed1 = Math.abs(p1.vx) + Math.abs(p1.vy);
                        const speed2 = Math.abs(p2.vx) + Math.abs(p2.vy);
                        const h1 = (hueCycle + p1.hueOffset + speed1*3) % 360;
                        const h2 = (hueCycle + p2.hueOffset + speed2*3) % 360;
                        
                        gradient.addColorStop(0, `hsla(${h1}, 100%, 70%, ${p1.lightIntensity * 0.6})`);
                        gradient.addColorStop(1, `hsla(${h2}, 100%, 70%, ${p2.lightIntensity * 0.6})`);
                        
                        tCtx.strokeStyle = gradient;
                        tCtx.lineWidth = 1.5;
                        tCtx.shadowBlur = 10;
                        tCtx.shadowColor = `hsl(${(h1 + h2) / 2}, 100%, 70%)`;
                        
                        tCtx.beginPath();
                        tCtx.moveTo(p1.x, p1.y);
                        tCtx.lineTo(p2.x, p2.y);
                        tCtx.stroke();
                        
                        connections++;
                    }
                }
            });
            
            tCtx.shadowBlur = 0;
            tCtx.restore();
        }

        // üíé REDUCED BLOOM WHITE BEAM üíé
        function drawWhiteBeam(fromX, fromY) {
            const toX = w/2;
            const toY = h/2;
            
            const litParticlesInBeam = [];
            const beamLength = Math.hypot(toX - fromX, toY - fromY);
            
            const minX = Math.min(fromX, toX) - 50;
            const maxX = Math.max(fromX, toX) + 50;
            const minY = Math.min(fromY, toY) - 50;
            const maxY = Math.max(fromY, toY) + 50;
            
            P.forEach(p => {
                if(p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) return;
                
                if(p.lightIntensity > 0.2) {
                    const dist = distanceToLine(p.x, p.y, fromX, fromY, toX, toY);
                    if(dist < 50) {
                        const dx = p.x - fromX;
                        const dy = p.y - fromY;
                        const beamDx = toX - fromX;
                        const beamDy = toY - fromY;
                        const projection = (dx * beamDx + dy * beamDy) / (beamLength * beamLength);
                        
                        if(projection > 0 && projection < 1) {
                            litParticlesInBeam.push({
                                position: projection,
                                intensity: p.lightIntensity
                            });
                        }
                    }
                }
            });
            
            litParticlesInBeam.sort((a, b) => a.position - b.position);
            
            let cumulativeAbsorption = 0;
            litParticlesInBeam.forEach(p => {
                cumulativeAbsorption += p.intensity * 0.12;
            });
            
            cumulativeAbsorption = Math.min(0.85, cumulativeAbsorption);
            const beamOpacity = 1 - cumulativeAbsorption;
            
            const gradient = lCtx.createLinearGradient(fromX, fromY, toX, toY);
            
            // Reduced opacity at source
            gradient.addColorStop(0, `rgba(255, 255, 255, ${0.5})`); // Was 0.9
            gradient.addColorStop(0.5, `rgba(220, 220, 255, ${0.35 * (1 - cumulativeAbsorption * 0.5)})`); // Was 0.7
            gradient.addColorStop(1, `rgba(180, 180, 255, ${0.2 * beamOpacity})`); // Was 0.4

            lCtx.save();
            lCtx.strokeStyle = gradient;
            lCtx.lineWidth = 25; // Slightly thinner (was 30)
            lCtx.lineCap = 'round';
            // 75% bloom reduction (25% of original)
            lCtx.shadowBlur = 10 * (0.5 + beamOpacity * 0.5); // Was 40
            lCtx.shadowColor = 'rgba(255, 255, 255, 0.4)'; // Reduced opacity
            
            lCtx.beginPath();
            lCtx.moveTo(fromX, fromY);
            lCtx.lineTo(toX, toY);
            lCtx.stroke();
            
            // Bright core - also reduced
            lCtx.lineWidth = 10; // Was 12
            lCtx.strokeStyle = `rgba(255, 255, 255, ${0.5 + beamOpacity * 0.15})`; // Was 0.8 + 0.2
            lCtx.shadowBlur = 5 * (0.5 + beamOpacity * 0.5); // Was 20
            lCtx.beginPath();
            lCtx.moveTo(fromX, fromY);
            lCtx.lineTo(toX, toY);
            lCtx.stroke();
            
            lCtx.restore();
        }

        // üåà‚ú® SEAMLESS PRISMATIC SPECTRUM ‚ú®üåà
        function drawRefractedRays(sourceX, sourceY) {
            const cx = w/2;
            const cy = h/2;
            
            const colors = [
                { hue: 0,   refractionOffset: -0.45 },
                { hue: 15,  refractionOffset: -0.4 },
                { hue: 30,  refractionOffset: -0.35 },
                { hue: 45,  refractionOffset: -0.3 },
                { hue: 60,  refractionOffset: -0.25 },
                { hue: 75,  refractionOffset: -0.2 },
                { hue: 90,  refractionOffset: -0.15 },
                { hue: 105, refractionOffset: -0.1 },
                { hue: 120, refractionOffset: -0.05 },
                { hue: 150, refractionOffset: 0 },
                { hue: 180, refractionOffset: 0.05 },
                { hue: 195, refractionOffset: 0.1 },
                { hue: 210, refractionOffset: 0.15 },
                { hue: 225, refractionOffset: 0.2 },
                { hue: 250, refractionOffset: 0.25 },
                { hue: 270, refractionOffset: 0.3 },
                { hue: 290, refractionOffset: 0.35 },
                { hue: 310, refractionOffset: 0.4 }
            ];

            armPositions.forEach((arm, armIndex) => {
                const dx = arm.x - sourceX;
                const dy = arm.y - sourceY;
                const incomingAngle = Math.atan2(dy, dx);
                
                colors.forEach(({ hue, refractionOffset }, colorIndex) => {
                    const refractedAngle = incomingAngle + Math.PI + refractionOffset;
                    
                    const rayLength = Math.max(w, h) * 1.2;
                    
                    const baseWidth = 35;
                    const startWidth = baseWidth * 0.8;
                    const endWidth = baseWidth * 2.0;
                    
                    const perpAngle = refractedAngle + Math.PI / 2;
                    
                    const startLeft = {
                        x: arm.x + Math.cos(perpAngle) * startWidth / 2,
                        y: arm.y + Math.sin(perpAngle) * startWidth / 2
                    };
                    const startRight = {
                        x: arm.x - Math.cos(perpAngle) * startWidth / 2,
                        y: arm.y - Math.sin(perpAngle) * startWidth / 2
                    };
                    
                    const endCenterX = arm.x + Math.cos(refractedAngle) * rayLength;
                    const endCenterY = arm.y + Math.sin(refractedAngle) * rayLength;
                    
                    const endLeft = {
                        x: endCenterX + Math.cos(perpAngle) * endWidth / 2,
                        y: endCenterY + Math.sin(perpAngle) * endWidth / 2
                    };
                    const endRight = {
                        x: endCenterX - Math.cos(perpAngle) * endWidth / 2,
                        y: endCenterY - Math.sin(perpAngle) * endWidth / 2
                    };

                    const gradient = lCtx.createLinearGradient(
                        arm.x, arm.y, endCenterX, endCenterY
                    );
                    
                    const color = `hsl(${hue}, 100%, 60%)`;
                    
                    gradient.addColorStop(0, color.replace(')', ', 0.4)').replace('hsl', 'hsla'));
                    gradient.addColorStop(0.15, color.replace(')', ', 0.25)').replace('hsl', 'hsla'));
                    gradient.addColorStop(0.35, color.replace(')', ', 0.12)').replace('hsl', 'hsla'));
                    gradient.addColorStop(0.6, color.replace(')', ', 0.04)').replace('hsl', 'hsla'));
                    gradient.addColorStop(1, color.replace(')', ', 0)').replace('hsl', 'hsla'));

                    lCtx.save();
                    lCtx.fillStyle = gradient;
                    lCtx.shadowBlur = 50;
                    lCtx.shadowColor = color.replace(')', ', 0.3)').replace('hsl', 'hsla');
                    lCtx.globalCompositeOperation = 'lighter';
                    
                    lCtx.beginPath();
                    lCtx.moveTo(startLeft.x, startLeft.y);
                    lCtx.lineTo(endLeft.x, endLeft.y);
                    lCtx.lineTo(endRight.x, endRight.y);
                    lCtx.lineTo(startRight.x, startRight.y);
                    lCtx.closePath();
                    lCtx.fill();
                    
                    lCtx.strokeStyle = color.replace(')', ', 0.15)').replace('hsl', 'hsla');
                    lCtx.lineWidth = startWidth * 0.4;
                    lCtx.lineCap = 'round';
                    lCtx.shadowBlur = 30;
                    lCtx.beginPath();
                    lCtx.moveTo(arm.x, arm.y);
                    lCtx.lineTo(arm.x + Math.cos(refractedAngle) * rayLength * 0.2, 
                                arm.y + Math.sin(refractedAngle) * rayLength * 0.2);
                    lCtx.stroke();
                    
                    lCtx.restore();
                });
            });
        }

        let canvasIsDragging = false;

        function updateTouches(e) {
            const target = e.target;
            if (target.tagName === 'BUTTON' || target.closest('#controls')) {
                return;
            }
            
            e.preventDefault();
            canvasIsDragging = true;
            
            touchPoints.length = 0;
            
            if(e.touches) {
                const numTouches = Math.min(e.touches.length, maxTouches);
                for(let i = 0; i < numTouches; i++) {
                    touchPoints.push({
                        x: e.touches[i].clientX,
                        y: e.touches[i].clientY,
                        id: e.touches[i].identifier
                    });
                }
            } else {
                touchPoints.push({
                    x: e.clientX,
                    y: e.clientY,
                    id: 0
                });
            }
        }
        
        function clearTouches() { 
            touchPoints.length = 0;
            canvasIsDragging = false;
        }

        document.addEventListener('touchstart', updateTouches, {passive:false});
        document.addEventListener('touchmove', updateTouches, {passive:false});
        document.addEventListener('touchend', (e) => {
            if(e.touches.length === 0) {
                clearTouches();
            } else {
                updateTouches(e);
            }
        });
        document.addEventListener('mousedown', updateTouches);
        document.addEventListener('mousemove', (e) => { 
            if(e.buttons === 1 && !e.target.closest('#controls')) {
                updateTouches(e);
            }
        });
        document.addEventListener('mouseup', clearTouches);

        const persistBtn = document.getElementById('persistBtn');
        persistBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            togglePersist();
        });
        persistBtn.addEventListener('touchstart', (e) => {
            e.stopPropagation();
        });
        persistBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            togglePersist();
        });

        function loop() {
            tCtx.globalCompositeOperation = 'source-over';
            tCtx.fillStyle = 'rgba(0, 0, 0, 0.09)';
            tCtx.fillRect(0, 0, w, h);
            
            tCtx.globalCompositeOperation = 'lighter';
            
            t += 0.02;
            hueCycle += 1;

            P.forEach(p => {
                p.update();
                p.draw();
            });
            
            drawLightWeb();

            if (!persistRays) {
                lCtx.clearRect(0, 0, w, h);
            } else {
                lCtx.fillStyle = 'rgba(0, 0, 0, 0.03)';
                lCtx.fillRect(0, 0, w, h);
            }

            if (touchPoints.length > 0) {
                touchPoints.forEach(touch => {
                    drawWhiteBeam(touch.x, touch.y);
                    drawRefractedRays(touch.x, touch.y);
                });
            }

            requestAnimationFrame(loop);
        }
        loop();

        function togglePersist() {
            persistRays = !persistRays;
            persistBtn.classList.toggle('active');
            if (!persistRays) {
                lCtx.clearRect(0, 0, w, h);
            }
        }
    </script>
</body>
</html>
