<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ΣΩ | V15 VOID CYCLONE</title>
    <style>
        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <script>
        const c = document.getElementById('c');
        const x = c.getContext('2d');
        
        let w, h;
        const P = []; 
        const N = 2500; // Particle Count
        
        // 3D CAMERA
        let camAngle = 0;
        let camY = -500; // Look slightly down
        let zoom = 800; // Field of View
        
        // VORTEX MATH
        const arms = 3;
        let time = 0;
        
        // INTERACTION
        let targetAngle = 0;
        let lastTouchX = 0;
        let isTouching = false;

        function resize() {
            w = c.width = window.innerWidth;
            h = c.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        class Part {
            constructor() {
                this.reset();
                // Start at random height to fill screen immediately
                this.y = (Math.random() - 0.5) * 2000; 
            }
            
            reset() {
                // Spawn at bottom
                this.y = 1000; 
                this.angle = Math.random() * Math.PI * 2;
                this.radius = 600 + Math.random() * 200; // Wide at bottom
                this.speed = 5 + Math.random() * 5;
                this.colorOffset = Math.random() * 100;
            }

            update() {
                // Move Up
                this.y -= this.speed;
                
                // Spiral In (Tornado shape)
                this.radius -= this.speed * 0.4;
                
                // Rotate (The Triskelion Logic in 3D)
                // We add extra speed based on which "Arm" it's closest to
                const armAngle = (Math.PI * 2 / arms);
                const localAngle = this.angle % armAngle;
                
                // Spin faster as we get closer to center (Conservation of angular momentum)
                this.angle += 0.02 + (100 / (this.radius + 10));

                // Reset if reached top or center
                if(this.y < -1000 || this.radius < 10) {
                    this.reset();
                }
            }

            draw() {
                // 1. CONVERT 3D (x,y,z) TO 2D (x,y)
                
                // Calculate 3D position
                // Triskelion Wave Offset
                const armOffset = Math.sin(this.angle * arms) * 50; 
                
                let px = Math.cos(this.angle) * (this.radius + armOffset);
                let pz = Math.sin(this.angle) * (this.radius + armOffset);
                let py = this.y;

                // Rotate World based on Camera
                let cos = Math.cos(camAngle);
                let sin = Math.sin(camAngle);
                
                let rx = px * cos - pz * sin;
                let rz = px * sin + pz * cos;
                
                // Depth Projection
                let perspective = zoom / (zoom + rz + 1000); // +1000 pushes it back into screen
                
                let sx = w/2 + rx * perspective;
                let sy = h/2 + py * perspective;
                
                // Scale size by depth
                let size = (4 * perspective) * 2;

                // Color Logic (Height map + Speed)
                // Bottom = Purple, Top = Cyan/White
                let hue = (time * 50 + this.colorOffset + (py + 1000) * 0.1) % 360;
                let light = Math.min(100, 30 + (size * 10)); // Closer = Brighter
                let alpha = Math.min(1, perspective); // Far away = Transparent

                x.fillStyle = `hsla(${hue}, 100%, ${light}%, ${alpha})`;
                
                // Only draw if in front of camera
                if(perspective > 0) {
                    x.beginPath();
                    x.arc(sx, sy, size, 0, Math.PI*2);
                    x.fill();
                }
            }
        }

        // INIT
        for(let i=0; i<N; i++) P.push(new Part());

        // TOUCH INPUT (Rotates Camera)
        window.addEventListener('touchstart', e => {
            isTouching = true;
            lastTouchX = e.touches[0].clientX;
        }, {passive: false});

        window.addEventListener('touchmove', e => {
            e.preventDefault(); // No scroll
            let tx = e.touches[0].clientX;
            let delta = (tx - lastTouchX) * 0.01;
            targetAngle -= delta; // Spin camera
            lastTouchX = tx;
        }, {passive: false});

        window.addEventListener('touchend', () => isTouching = false);

        // LOOP
        function loop() {
            // DEEP SPACE FADE
            x.globalCompositeOperation = 'source-over';
            x.fillStyle = 'rgba(0, 0, 5, 0.2)'; 
            x.fillRect(0, 0, w, h);
            
            // NEON ADDITIVE BLEND
            x.globalCompositeOperation = 'lighter'; 
            
            // Camera Physics (Smooth rotation)
            if(!isTouching) targetAngle += 0.005; // Auto rotate
            camAngle += (targetAngle - camAngle) * 0.1;
            time += 0.01;

            // Sort particles by Z (Depth) so they overlap correctly-ish
            // (Optional in additive mode, but looks better)
            // Note: Skipping full sort for performance, rely on additive blending

            P.forEach(p => {
                p.update();
                p.draw();
            });

            requestAnimationFrame(loop);
        }
        loop();

    </script>
</body>
</html>
