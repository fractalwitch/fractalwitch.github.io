<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>RESONANCE SORTER ∞ ELYSIUM NEXUS</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Cinzel+Decorative:wght@400;700&family=DM+Sans:wght@300;400&display=swap" rel="stylesheet">
<style>
  :root {
    --void: #030308;
    --deep: #07071a;
    --c1: #ff6ec7;
    --c2: #a78bfa;
    --c3: #67e8f9;
    --c4: #86efac;
    --c5: #fde68a;
    --c6: #fb923c;
    --glow: rgba(167,139,250,0.4);
    --mono: 'Space Mono', monospace;
    --display: 'Cinzel Decorative', serif;
    --body: 'DM Sans', sans-serif;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--void);
    color: #fff;
    font-family: var(--body);
    overflow: hidden;
    width: 100vw;
    height: 100vh;
  }

  /* ── STARFIELD BG ── */
  #bg-stars {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
  }

  /* ── SCREENS ── */
  .screen {
    position: fixed;
    inset: 0;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: opacity 0.8s ease;
  }
  .screen.hidden { opacity: 0; pointer-events: none; }

  /* ── LOGIN SCREEN ── */
  #login-screen {
    background: radial-gradient(ellipse at 50% 40%, rgba(100,60,180,0.25) 0%, transparent 65%),
                radial-gradient(ellipse at 20% 80%, rgba(255,110,199,0.15) 0%, transparent 50%),
                var(--void);
  }

  .sigil {
    width: 120px;
    height: 120px;
    margin-bottom: 2rem;
    animation: sigil-pulse 4s ease-in-out infinite;
  }

  @keyframes sigil-pulse {
    0%,100% { filter: drop-shadow(0 0 20px var(--c2)) drop-shadow(0 0 40px rgba(167,139,250,0.3)); transform: scale(1) rotate(0deg); }
    50% { filter: drop-shadow(0 0 35px var(--c1)) drop-shadow(0 0 70px rgba(255,110,199,0.4)); transform: scale(1.05) rotate(3deg); }
  }

  h1.title {
    font-family: var(--display);
    font-size: clamp(1.4rem, 4vw, 2.8rem);
    letter-spacing: 0.15em;
    text-align: center;
    background: linear-gradient(135deg, var(--c1), var(--c2), var(--c3));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 0.4rem;
  }

  h2.subtitle {
    font-family: var(--mono);
    font-size: 0.75rem;
    letter-spacing: 0.4em;
    color: rgba(255,255,255,0.35);
    text-transform: uppercase;
    margin-bottom: 3rem;
  }

  .input-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    width: min(420px, 90vw);
    margin-bottom: 1.5rem;
  }

  .input-label {
    font-family: var(--mono);
    font-size: 0.65rem;
    letter-spacing: 0.3em;
    color: var(--c3);
    text-transform: uppercase;
  }

  .input-field {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(167,139,250,0.3);
    border-radius: 4px;
    padding: 0.75rem 1rem;
    color: #fff;
    font-family: var(--mono);
    font-size: 0.8rem;
    width: 100%;
    transition: border-color 0.3s, box-shadow 0.3s;
    outline: none;
  }

  .input-field:focus {
    border-color: var(--c2);
    box-shadow: 0 0 20px rgba(167,139,250,0.2);
  }

  .redirect-hint {
    font-family: var(--mono);
    font-size: 0.6rem;
    color: rgba(255,255,255,0.3);
    margin-top: 0.3rem;
  }
  .redirect-hint span { color: var(--c3); }

  .btn-conjure {
    margin-top: 1rem;
    padding: 1rem 2.5rem;
    background: linear-gradient(135deg, rgba(167,139,250,0.2), rgba(255,110,199,0.2));
    border: 1px solid rgba(167,139,250,0.5);
    border-radius: 4px;
    color: #fff;
    font-family: var(--display);
    font-size: 0.85rem;
    letter-spacing: 0.2em;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }

  .btn-conjure::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--c2), var(--c1));
    opacity: 0;
    transition: opacity 0.3s;
  }

  .btn-conjure:hover::before { opacity: 0.15; }
  .btn-conjure:hover {
    border-color: var(--c1);
    box-shadow: 0 0 30px rgba(255,110,199,0.3), 0 0 60px rgba(167,139,250,0.2);
    transform: translateY(-2px);
  }
  .btn-conjure span { position: relative; z-index: 1; }

  /* ── LOADING SCREEN ── */
  #loading-screen {
    background: var(--void);
    gap: 2rem;
  }

  .loading-orb {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, rgba(167,139,250,0.8), rgba(255,110,199,0.4), transparent);
    animation: orb-spin 3s linear infinite;
    box-shadow: 0 0 40px rgba(167,139,250,0.5);
  }

  @keyframes orb-spin {
    0% { transform: rotate(0deg) scale(1); box-shadow: 0 0 40px rgba(167,139,250,0.5); }
    33% { transform: rotate(120deg) scale(1.1); box-shadow: 0 0 60px rgba(255,110,199,0.5); }
    66% { transform: rotate(240deg) scale(0.95); box-shadow: 0 0 40px rgba(103,232,249,0.5); }
    100% { transform: rotate(360deg) scale(1); box-shadow: 0 0 40px rgba(167,139,250,0.5); }
  }

  #load-status {
    font-family: var(--mono);
    font-size: 0.75rem;
    color: var(--c2);
    letter-spacing: 0.2em;
    text-align: center;
  }

  #load-progress-bar {
    width: min(320px, 80vw);
    height: 2px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    overflow: hidden;
  }

  #load-progress-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--c2), var(--c1), var(--c3));
    transition: width 0.3s ease;
    border-radius: 2px;
  }

  #load-count {
    font-family: var(--mono);
    font-size: 0.65rem;
    color: rgba(255,255,255,0.3);
    letter-spacing: 0.1em;
  }

  /* ── VIZ SCREEN ── */
  #viz-screen {
    z-index: 5;
    pointer-events: none;
  }

  #grid-canvas {
    position: fixed;
    inset: 0;
    z-index: 5;
    pointer-events: none;
  }

  #viz-canvas {
    position: fixed;
    inset: 0;
    z-index: 4;
    cursor: crosshair;
  }

  /* ── HUD ── */
  #hud {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 20;
    pointer-events: none;
    padding: 1.2rem 1.5rem;
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 1rem;
  }
  #hud.hidden { display: none; }

  .hud-title {
    font-family: var(--display);
    font-size: 0.9rem;
    letter-spacing: 0.2em;
    background: linear-gradient(135deg, var(--c1), var(--c2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .hud-count {
    font-family: var(--mono);
    font-size: 0.6rem;
    color: rgba(255,255,255,0.3);
    letter-spacing: 0.15em;
    margin-top: 0.2rem;
  }

  /* ── LEGEND ── */
  #legend {
    position: fixed;
    bottom: 1.5rem;
    left: 1.5rem;
    z-index: 20;
    pointer-events: none;
    font-family: var(--mono);
    font-size: 0.6rem;
    letter-spacing: 0.1em;
    color: rgba(255,255,255,0.4);
    line-height: 1.8;
  }
  #legend.hidden { display: none; }

  .legend-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  /* ── AXIS LABELS ── */
  .axis-label {
    position: fixed;
    z-index: 20;
    font-family: var(--mono);
    font-size: 0.55rem;
    letter-spacing: 0.3em;
    color: rgba(255,255,255,0.2);
    text-transform: uppercase;
    pointer-events: none;
  }
  .axis-label.hidden { display: none; }

  #ax-left { bottom: 50%; left: 1.5rem; transform: rotate(-90deg) translateX(50%); }
  #ax-right { bottom: 50%; right: 1.5rem; transform: rotate(90deg) translateX(50%); }
  #ax-right { bottom: 50%; right: 1.5rem; transform: rotate(90deg) translateX(50%); }
  #ax-top { top: 4.5rem; left: 50%; transform: translateX(-50%); }
  #ax-bottom { bottom: 1.5rem; left: 50%; transform: translateX(-50%); }

  /* ── TOOLTIP ── */
  #tooltip {
    position: fixed;
    z-index: 30;
    pointer-events: none;
    background: rgba(3,3,8,0.92);
    border: 1px solid rgba(167,139,250,0.4);
    border-radius: 6px;
    padding: 0.8rem 1rem;
    max-width: 260px;
    backdrop-filter: blur(20px);
    transform: translate(-50%, -120%);
    transition: opacity 0.15s;
    opacity: 0;
  }

  #tooltip.visible { opacity: 1; }

  .tt-artist {
    font-family: var(--mono);
    font-size: 0.6rem;
    color: var(--c2);
    letter-spacing: 0.15em;
    text-transform: uppercase;
    margin-bottom: 0.2rem;
  }

  .tt-track {
    font-family: var(--body);
    font-size: 0.9rem;
    font-weight: 400;
    color: #fff;
    margin-bottom: 0.5rem;
    line-height: 1.3;
  }

  .tt-stats {
    display: flex;
    gap: 0.8rem;
    flex-wrap: wrap;
  }

  .tt-stat {
    font-family: var(--mono);
    font-size: 0.55rem;
    color: rgba(255,255,255,0.4);
    letter-spacing: 0.1em;
  }

  .tt-stat span { color: var(--c3); }

  .tt-hint {
    font-family: var(--mono);
    font-size: 0.5rem;
    color: rgba(255,255,255,0.2);
    margin-top: 0.5rem;
    letter-spacing: 0.1em;
  }

  /* ── CONTROLS ── */
  #controls {
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    z-index: 20;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    pointer-events: all;
  }
  #controls.hidden { display: none; }

  .ctrl-btn {
    width: 36px;
    height: 36px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(167,139,250,0.2);
    border-radius: 4px;
    color: rgba(255,255,255,0.5);
    font-family: var(--mono);
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .ctrl-btn:hover {
    background: rgba(167,139,250,0.15);
    border-color: var(--c2);
    color: #fff;
  }

  /* ── COLOR MODE TOGGLE ── */
  #color-mode {
    position: fixed;
    top: 4.5rem;
    right: 1.5rem;
    z-index: 20;
    display: flex;
    gap: 0.4rem;
    pointer-events: all;
  }
  #color-mode.hidden { display: none; }

  .mode-btn {
    padding: 0.3rem 0.7rem;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 3px;
    color: rgba(255,255,255,0.3);
    font-family: var(--mono);
    font-size: 0.55rem;
    letter-spacing: 0.1em;
    cursor: pointer;
    transition: all 0.2s;
  }

  .mode-btn.active {
    background: rgba(167,139,250,0.15);
    border-color: var(--c2);
    color: var(--c2);
  }
  .mode-btn.switching { animation: modePulse 0.4s ease; }
  @keyframes modePulse {
    0%   { transform: scale(1);    box-shadow: 0 0 0px rgba(167,139,250,0); }
    45%  { transform: scale(1.1);  box-shadow: 0 0 14px rgba(167,139,250,0.5); }
    100% { transform: scale(1);    box-shadow: 0 0 0px rgba(167,139,250,0); }
  }
  .axis-label { transition: opacity 0.25s ease; }

  /* ── SETTINGS BUTTON ── */
  #settings-btn {
    position: fixed;
    bottom: 1.4rem;
    left: 1.4rem;
    width: 36px;
    height: 36px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(167,139,250,0.2);
    border-radius: 50%;
    color: rgba(255,255,255,0.45);
    font-size: 1rem;
    cursor: pointer;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 40;
    transition: all 0.25s ease;
  }
  #settings-btn:hover { background: rgba(167,139,250,0.15); color: #a78bfa; border-color: rgba(167,139,250,0.5); }
  #settings-btn.has-error {
    border-color: rgba(255,100,100,0.6);
    color: rgba(255,130,130,0.9);
    animation: flagPulse 2.5s ease-in-out infinite;
  }
  @keyframes flagPulse {
    0%,100% { box-shadow: 0 0 0px rgba(255,100,100,0); }
    50%      { box-shadow: 0 0 10px rgba(255,100,100,0.4); }
  }

  /* ── SETTINGS PANEL ── */
  #settings-panel {
    position: fixed;
    bottom: 4.6rem;
    left: 1.4rem;
    width: 280px;
    background: rgba(6,4,14,0.96);
    border: 1px solid rgba(167,139,250,0.25);
    border-radius: 10px;
    padding: 1.2rem;
    z-index: 50;
    display: none;
    backdrop-filter: blur(12px);
    font-family: var(--mono);
    transform-origin: bottom left;
    animation: panelOpen 0.2s cubic-bezier(0.34,1.56,0.64,1);
  }
  @keyframes panelOpen {
    from { opacity:0; transform: scale(0.88) translateY(8px); }
    to   { opacity:1; transform: scale(1) translateY(0); }
  }
  .sp-title {
    font-size: .6rem;
    letter-spacing: .2em;
    color: rgba(167,139,250,0.7);
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: .5rem;
  }
  .sp-title::after {
    content: '';
    flex: 1;
    height: 1px;
    background: rgba(167,139,250,0.15);
  }
  .sp-error {
    background: rgba(255,60,60,0.07);
    border: 1px solid rgba(255,80,80,0.25);
    border-radius: 6px;
    padding: .7rem .8rem;
    margin-bottom: .9rem;
    display: none;
  }
  .sp-error-label {
    font-size: .48rem;
    letter-spacing: .15em;
    color: rgba(255,120,120,0.7);
    margin-bottom: .35rem;
  }
  .sp-error-msg {
    font-size: .58rem;
    color: rgba(255,160,160,0.85);
    line-height: 1.6;
    letter-spacing: .03em;
  }
  .sp-section {
    margin-bottom: .9rem;
  }
  .sp-label {
    font-size: .48rem;
    letter-spacing: .15em;
    color: rgba(255,255,255,0.25);
    margin-bottom: .3rem;
  }
  .sp-value {
    font-size: .55rem;
    color: rgba(255,255,255,0.35);
    letter-spacing: .05em;
    overflow: hidden;
  }
  .sp-value div {
    white-space: pre;
    line-height: 1.8;
    font-size: .53rem;
  }
  .sp-btn {
    width: 100%;
    padding: .55rem;
    background: transparent;
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 5px;
    color: rgba(255,255,255,0.4);
    font-family: var(--mono);
    font-size: .58rem;
    letter-spacing: .15em;
    cursor: pointer;
    transition: all 0.2s;
    margin-top: .4rem;
  }
  .sp-btn:hover { background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.7); border-color: rgba(255,255,255,0.25); }
  .sp-btn.danger { border-color: rgba(255,100,100,0.25); color: rgba(255,130,130,0.6); }
  .sp-btn.danger:hover { background: rgba(255,60,60,0.08); color: rgba(255,160,160,0.9); border-color: rgba(255,100,100,0.5); }

  /* ── DEBUG LOG ── */
  #sp-debug {
    margin-top: .8rem;
    background: rgba(0,0,0,0.4);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 5px;
    padding: .6rem .7rem;
    max-height: 160px;
    overflow-y: auto;
    display: none;
  }
  #sp-debug-toggle {
    background: none; border: none;
    color: rgba(255,255,255,0.2);
    font-family: var(--mono); font-size: .45rem;
    letter-spacing: .12em; cursor: pointer;
    padding: .3rem 0; width: 100%; text-align: left;
    margin-top: .5rem;
  }
  #sp-debug-toggle:hover { color: rgba(255,255,255,0.45); }
  .dbg-line {
    font-family: var(--mono); font-size: .48rem;
    letter-spacing: .04em; line-height: 1.7;
    border-bottom: 1px solid rgba(255,255,255,0.04);
    padding: .15rem 0;
  }
  .dbg-ok  { color: rgba(120,220,120,0.8); }
  .dbg-err { color: rgba(255,120,120,0.9); }
  .dbg-warn{ color: rgba(255,200,80,0.8); }
  .dbg-info{ color: rgba(160,160,255,0.7); }

  /* ── CLUSTER NAMES ── */
  .cluster-label {
    position: fixed;
    pointer-events: none;
    font-family: var(--mono);
    font-size: 0.55rem;
    letter-spacing: 0.15em;
    color: rgba(255,255,255,0.18);
    text-transform: uppercase;
    white-space: nowrap;
    z-index: 15;
  }

  /* ── SEARCH ── */
  #search-wrap {
    position: fixed;
    top: 4.5rem;
    left: 1.5rem;
    z-index: 20;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    pointer-events: all;
  }
  #search-wrap.hidden { display: none; }

  #search-input {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(167,139,250,0.2);
    border-radius: 3px;
    padding: 0.4rem 0.7rem;
    color: #fff;
    font-family: var(--mono);
    font-size: 0.65rem;
    width: 180px;
    outline: none;
    transition: all 0.2s;
    letter-spacing: 0.05em;
  }
  #search-input:focus {
    border-color: var(--c2);
    background: rgba(167,139,250,0.08);
  }
  #search-input::placeholder { color: rgba(255,255,255,0.2); }

  /* ── ERROR ── */
  #error-msg {
    font-family: var(--mono);
    font-size: 0.7rem;
    color: #ff6b6b;
    text-align: center;
    margin-top: 1rem;
    max-width: 380px;
    line-height: 1.6;
    display: none;
  }

  /* ── SONG CARD (mobile tap) ── */
  #song-card {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 35;
    background: rgba(3,3,8,0.96);
    border-top: 1px solid rgba(167,139,250,0.3);
    padding: 1.2rem 1.5rem 2rem;
    backdrop-filter: blur(30px);
    transform: translateY(100%);
    transition: transform 0.35s cubic-bezier(0.32,0.72,0,1);
    display: none;
  }
  #song-card.visible {
    transform: translateY(0);
  }
  #song-card .sc-pill {
    width: 40px;
    height: 4px;
    background: rgba(255,255,255,0.2);
    border-radius: 2px;
    margin: 0 auto 1.2rem;
  }
  #song-card .sc-artist {
    font-family: var(--mono);
    font-size: 0.6rem;
    color: var(--c2);
    letter-spacing: 0.2em;
    text-transform: uppercase;
    margin-bottom: 0.3rem;
  }
  #song-card .sc-track {
    font-family: var(--body);
    font-size: 1.2rem;
    color: #fff;
    margin-bottom: 0.8rem;
    line-height: 1.3;
  }
  #song-card .sc-stats {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    margin-bottom: 1rem;
  }
  #song-card .sc-stat {
    font-family: var(--mono);
    font-size: 0.6rem;
    color: rgba(255,255,255,0.4);
    letter-spacing: 0.1em;
  }
  #song-card .sc-stat span { color: var(--c3); }
  #song-card .sc-open {
    width: 100%;
    padding: 0.8rem;
    background: rgba(30,215,96,0.15);
    border: 1px solid rgba(30,215,96,0.4);
    border-radius: 4px;
    color: #1ed760;
    font-family: var(--mono);
    font-size: 0.7rem;
    letter-spacing: 0.2em;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
  }
  #song-card .sc-open:hover, #song-card .sc-open:active {
    background: rgba(30,215,96,0.25);
  }

  /* ── MOBILE OVERRIDES ── */
  @media (max-width: 768px) {
    .sigil { width: 80px; height: 80px; margin-bottom: 1.2rem; }

    h1.title { font-size: clamp(1rem, 5vw, 1.6rem); }

    h2.subtitle {
      font-size: 0.6rem;
      letter-spacing: 0.2em;
      margin-bottom: 2rem;
    }

    .input-group { margin-bottom: 1rem; }
    .input-field { font-size: 0.9rem; padding: 0.9rem 1rem; }

    .btn-conjure { padding: 0.9rem 2rem; width: min(300px, 85vw); }

    #hud { padding: 0.8rem 1rem; }
    .hud-title { font-size: 0.7rem; }
    .hud-count { font-size: 0.5rem; }

    /* hide legend on mobile - info is in card */
    #legend { display: none !important; }

    /* axis labels smaller */
    .axis-label { font-size: 0.45rem; letter-spacing: 0.15em; }
    #ax-bottom { font-size: 0.4rem; }

    /* color modes compact */
    #color-mode { top: 3.8rem; right: 0.8rem; gap: 0.25rem; }
    .mode-btn { padding: 0.25rem 0.5rem; font-size: 0.5rem; }

    /* search full-ish width */
    #search-wrap { top: 3.8rem; left: 0.8rem; }
    #search-input { width: 130px; font-size: 0.6rem; }

    /* controls bigger tap targets */
    #controls { bottom: 0.8rem; right: 0.8rem; }
    .ctrl-btn { width: 44px; height: 44px; font-size: 1.2rem; }

    /* tooltip hidden on mobile - use card instead */
    #tooltip { display: none !important; }
  }

  @media (max-width: 400px) {
    h1.title { font-size: 1rem; letter-spacing: 0.08em; }
    h2.subtitle { display: none; }
    #search-input { width: 110px; }
  }
</style>
</head>
<body>

<!-- ambient bg stars -->
<canvas id="bg-stars"></canvas>

<!-- ── LOGIN ── -->
<div id="login-screen" class="screen">
  <svg class="sigil" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
    <circle cx="60" cy="60" r="55" stroke="rgba(167,139,250,0.3)" stroke-width="1"/>
    <circle cx="60" cy="60" r="40" stroke="rgba(255,110,199,0.25)" stroke-width="1"/>
    <circle cx="60" cy="60" r="25" stroke="rgba(103,232,249,0.2)" stroke-width="1"/>
    <path d="M60 10 L67 40 L98 40 L73 58 L83 88 L60 72 L37 88 L47 58 L22 40 L53 40 Z" fill="none" stroke="rgba(167,139,250,0.5)" stroke-width="1.5" stroke-linejoin="round"/>
    <circle cx="60" cy="60" r="5" fill="rgba(255,110,199,0.6)"/>
    <circle cx="60" cy="10" r="2.5" fill="rgba(103,232,249,0.6)"/>
    <circle cx="98" cy="40" r="2" fill="rgba(167,139,250,0.6)"/>
    <circle cx="22" cy="40" r="2" fill="rgba(167,139,250,0.6)"/>
    <circle cx="83" cy="88" r="2" fill="rgba(254,215,170,0.6)"/>
    <circle cx="37" cy="88" r="2" fill="rgba(134,239,172,0.6)"/>
  </svg>

  <h1 class="title">RESONANCE SORTER</h1>
  <h2 class="subtitle">∞ elysium nexus ∞ sonic cartography ∞</h2>

  <div class="input-group">
    <div class="input-label">Spotify Client ID</div>
    <input type="text" id="client-id-input" class="input-field" placeholder="paste your client id here" autocomplete="off" spellcheck="false"/>
    <div class="redirect-hint">add <span>http://localhost:3000</span> (desktop) or your hosted URL to Spotify redirect URIs</div>
  </div>

  <div class="input-group">
    <div class="input-label">Last.fm API Key <span style="color:rgba(255,255,255,0.2);font-size:0.55rem;letter-spacing:0.1em">FREE at last.fm/api/account/create</span></div>
    <input type="text" id="lastfm-key-input" class="input-field" placeholder="paste last.fm key for real genre data ✦" autocomplete="off" spellcheck="false"/>
  </div>

  <button class="btn-conjure" onclick="initiateAuth().catch(e => showError(e.message))">
    <span>✦ OPEN THE PORTAL ✦</span>
  </button>

  <div id="error-msg"></div>

  <div style="margin-top:3rem; font-family: var(--mono); font-size: 0.58rem; color: rgba(255,255,255,0.15); text-align: center; letter-spacing: 0.1em; line-height: 2;">
    X AXIS: VALENCE (melancholy → euphoria) &nbsp;·&nbsp; Y AXIS: ENERGY (drift → surge)<br>
    COLOR: SONIC SIGNATURE &nbsp;·&nbsp; SIZE: DANCEABILITY
  </div>
</div>

<!-- ── LOADING ── -->
<div id="loading-screen" class="screen hidden">
  <div class="loading-orb"></div>
  <div id="load-status">INITIATING RESONANCE SCAN...</div>
  <div id="load-progress-bar"><div id="load-progress-fill"></div></div>
  <div id="load-count">preparing to receive transmission</div>
  <div id="load-detail" style="margin-top:.6rem;font-family:var(--mono);font-size:.58rem;color:rgba(255,100,100,0.6);letter-spacing:.08em;min-height:1.2em;text-align:center;max-width:80%;"></div>
  <button id="load-back-btn" onclick="abortAndReturn()" style="display:none;margin-top:2rem;padding:.6rem 1.5rem;background:transparent;border:1px solid rgba(167,139,250,0.3);border-radius:4px;color:rgba(255,255,255,0.4);font-family:var(--mono);font-size:.65rem;letter-spacing:.15em;cursor:pointer;">← back to portal</button>
</div>

<!-- ── HUD ── -->
<div id="hud" class="hidden">
  <div>
    <div class="hud-title">RESONANCE SORTER</div>
    <div class="hud-count" id="hud-count">— songs mapped</div>
    <button onclick="rescanLibrary()" title="rescan library from Spotify" style="background:transparent;border:none;color:rgba(255,255,255,0.12);font-family:var(--mono);font-size:.48rem;letter-spacing:.1em;cursor:pointer;padding:.15rem 0;display:block;margin-top:.1rem">⟳ rescan library</button>
  </div>
</div>

<!-- ── AXIS LABELS ── -->
<div class="axis-label hidden" id="ax-left">MELANCHOLY</div>
<div class="axis-label hidden" id="ax-right">EUPHORIC</div>
<div class="axis-label hidden" id="ax-top">ENERGETIC</div>
<div class="axis-label hidden" id="ax-bottom">MELLOW</div>

<!-- ── COLOR MODE ── -->
<div id="color-mode" class="hidden">
  <button class="mode-btn active" onclick="setColorMode('genre')" id="cm-genre">SONIC</button>
  <button class="mode-btn" onclick="setColorMode('energy')" id="cm-energy">ENERGY</button>
  <button class="mode-btn" onclick="setColorMode('tempo')" id="cm-tempo">TEMPO</button>
  <button class="mode-btn" onclick="setColorMode('dance')" id="cm-dance">DANCE</button>
</div>

<!-- ── SEARCH ── -->
<div id="search-wrap" class="hidden">
  <input type="text" id="search-input" placeholder="search songs..." oninput="handleSearch(this.value)"/>
</div>

<!-- ── MAIN VIZ CANVAS ── -->
<canvas id="grid-canvas"></canvas>
<canvas id="viz-canvas" class="hidden"></canvas>

<!-- ── LEGEND ── -->
<div id="legend" class="hidden">
  <div id="legend-items">
    <div class="legend-row"><div class="legend-dot" style="background:#6366f1"></div> melancholy · still</div>
    <div class="legend-row"><div class="legend-dot" style="background:#a78bfa"></div> complex · introspective</div>
    <div class="legend-row"><div class="legend-dot" style="background:#67e8f9"></div> chill · dreamy</div>
    <div class="legend-row"><div class="legend-dot" style="background:#86efac"></div> bright · peaceful</div>
    <div class="legend-row"><div class="legend-dot" style="background:#fde68a"></div> euphoric · driving</div>
    <div class="legend-row"><div class="legend-dot" style="background:#f97316"></div> intense · dancing</div>
  </div>
  <div style="margin-top:0.5rem; color: rgba(255,255,255,0.2);">scroll: zoom · drag: pan · click: open in spotify</div>
</div>

<!-- ── CONTROLS ── -->
<div id="controls" class="hidden">
  <button class="ctrl-btn" onclick="resetView()" title="reset view">⊙</button>
  <button class="ctrl-btn" onclick="zoomIn()" title="zoom in">+</button>
  <button class="ctrl-btn" onclick="zoomOut()" title="zoom out">−</button>
</div>

<!-- ── SETTINGS BUTTON ── -->
<button id="settings-btn" onclick="toggleSettings()" title="settings">⚙</button>

<!-- ── SETTINGS PANEL ── -->
<div id="settings-panel">
  <div class="sp-title">SETTINGS</div>

  <!-- error readout — only visible when errors present -->
  <div class="sp-error" id="sp-error-block">
    <div class="sp-error-label">⚑ SYSTEM ALERT</div>
    <div class="sp-error-msg" id="sp-error-msg"></div>
  </div>

  <!-- current API keys (display only) -->
  <div class="sp-section">
    <div class="sp-label">SPOTIFY CLIENT ID</div>
    <div class="sp-value" id="sp-client-id">—</div>
  </div>
  <div class="sp-section">
    <div class="sp-label">LAST.FM API KEY</div>
    <div class="sp-value" id="sp-lastfm-key">—</div>
  </div>

  <!-- crystallization status -->
  <div class="sp-section">
    <div class="sp-label">CRYSTALLIZATION</div>
    <div class="sp-value" id="sp-crystal-status">—</div>
  </div>

  <button class="sp-btn" onclick="retryEnrichment()">⟳ RETRY CRYSTALLIZATION</button>
  <button class="sp-btn danger" onclick="logOut()">↩ LOG OUT</button>

  <button id="sp-debug-toggle" onclick="toggleDebugLog()">▸ SHOW DEBUG LOG</button>
  <div id="sp-debug"></div>

</div>

<!-- ── TOOLTIP ── -->
<div id="tooltip">
  <div class="tt-artist" id="tt-artist"></div>
  <div class="tt-track" id="tt-track"></div>
  <div class="tt-stats" id="tt-stats"></div>
  <div class="tt-hint">click to open in spotify</div>
</div>

<!-- ── MOBILE SONG CARD ── -->
<div id="song-card">
  <div class="sc-pill"></div>
  <div class="sc-artist" id="sc-artist"></div>
  <div class="sc-track" id="sc-track"></div>
  <div class="sc-stats" id="sc-stats"></div>
  <button class="sc-open" id="sc-open-btn">↗ OPEN IN SPOTIFY</button>
</div>

<script>

// ═══════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════
const SCOPES = 'user-library-read';
let accessToken=null, clientId=null, lastfmKey=null;
let songs=[], colorMode='genre', searchQuery='';

// Camera
let camX=0, camY=0, camZoom=1;
let isDragging=false, dragStartX=0, dragStartY=0, dragCamX=0, dragCamY=0;
let hoveredSong=null, mouseX=0, mouseY=0;

// Touch
const isMobile=()=>('ontouchstart' in window)||window.matchMedia('(max-width:768px)').matches;
let lastTouchDist=null, touchStartX=0, touchStartY=0, touchMoved=false;
let pinnedSong=-1, songCardUrl=null;

// Positions + animated transitions
let worldPositions=null;
let posTransitions={};

// ── FEATURE CACHE ─────────────────────────────────
const CACHE_KEY='rs_features_v5'; // v5: added genre+audio checksum
let featureCache={};

function loadFeatureCache(){
  try{featureCache=JSON.parse(localStorage.getItem(CACHE_KEY)||'{}');}
  catch{featureCache={};}
  // Wipe stale no-id markers so genre enrichment retries properly
  let wiped=0;
  for(const id of Object.keys(featureCache)){
    if(featureCache[id]?._v?.g==='no-id'||featureCache[id]?._v?.g===false){
      delete featureCache[id]._v.g;
      wiped++;
    }
  }
  if(wiped>0) console.log('[GENRE] wiped '+wiped+' stale no-id markers');
}
let _saveTimer=null;
function queueSave(){
  clearTimeout(_saveTimer);
  _saveTimer=setTimeout(()=>{try{localStorage.setItem(CACHE_KEY,JSON.stringify(featureCache));}catch{}},2500);
}

// ── SYNTHETIC (deterministic seed) ───────────────
function synth(track){
  let h=0;
  for(let i=0;i<track.id.length;i++) h=Math.imul(31,h)+track.id.charCodeAt(i)|0;
  const r=(o=0)=>{let x=Math.sin(h+o)*43758.5453123;return x-Math.floor(x);};
  const pop=(track.popularity||50)/100;
  return{
    valence:Math.max(.02,Math.min(.98,pop*.4+r(1)*.65)),
    energy:Math.max(.02,Math.min(.98,pop*.3+r(2)*.72)),
    danceability:Math.max(.02,Math.min(.98,pop*.35+r(3)*.62)),
    tempo:80+r(4)*120, source:'synthetic',
  };
}

// ── LASTFM TAG → FEATURES ─────────────────────────
const TAG_MAP={
  happy:{v:.85},upbeat:{v:.82},'feel good':{v:.80},cheerful:{v:.84},joyful:{v:.88},
  fun:{v:.78},uplifting:{v:.82},euphoric:{v:.92},blissful:{v:.9},carefree:{v:.82},
  sunny:{v:.82},playful:{v:.8},optimistic:{v:.78},bright:{v:.78},
  sad:{v:.15},melancholy:{v:.14},melancholic:{v:.14},depressing:{v:.1},
  heartbreak:{v:.14},grief:{v:.1},gloomy:{v:.12},somber:{v:.18},
  dark:{v:.22,e:.55},haunting:{v:.25,e:.45},ominous:{v:.2,e:.55},
  emotional:{v:.35},nostalgic:{v:.42},bittersweet:{v:.45},
  romantic:{v:.65},love:{v:.72},dreamy:{v:.58,e:.32},ethereal:{v:.55,e:.3},
  angry:{v:.2,e:.88},aggressive:{v:.22,e:.9},tense:{v:.3,e:.75},
  mysterious:{v:.4,e:.45},eerie:{v:.25,e:.4},
  hopeful:{v:.68},longing:{v:.42},wistful:{v:.45},yearning:{v:.38},
  peaceful:{v:.72,e:.18},serene:{v:.75,e:.15},tranquil:{v:.73,e:.16},
  energetic:{e:.88},intense:{e:.85},powerful:{e:.82},heavy:{e:.8},
  driving:{e:.78},explosive:{e:.92},frantic:{e:.9},relentless:{e:.85},
  calm:{e:.2},relaxing:{e:.15},chill:{e:.25},mellow:{e:.28},soft:{e:.22},
  gentle:{e:.22},quiet:{e:.2},ambient:{e:.2,d:.25},meditative:{e:.15},
  hypnotic:{e:.5,d:.65},atmospheric:{e:.3},soothing:{e:.18},
  dance:{d:.85,e:.78},danceable:{d:.85},groovy:{d:.82},funky:{d:.8,v:.72},
  rhythmic:{d:.75},bouncy:{d:.8,v:.78},infectious:{d:.82,v:.75},
  electronic:{e:.72,d:.72},electro:{e:.75,d:.75},
  techno:{e:.88,d:.88,v:.38},house:{e:.78,d:.85,v:.62},
  'deep house':{e:.65,d:.82,v:.58},trance:{e:.82,d:.82,v:.55},
  'drum and bass':{e:.9,d:.82},dnb:{e:.9,d:.82},
  dubstep:{e:.85,d:.72,v:.35},edm:{e:.82,d:.82},
  synthwave:{e:.65,d:.72,v:.55},retrowave:{e:.65,d:.7,v:.55},
  darkwave:{e:.55,v:.25,d:.45},coldwave:{e:.5,v:.22,d:.42},
  industrial:{e:.82,v:.22,d:.55},ebm:{e:.78,v:.28,d:.72},noise:{e:.9,v:.18},
  'hip hop':{e:.65,d:.78},'hip-hop':{e:.65,d:.78},
  rap:{e:.7,d:.75},trap:{e:.72,d:.82,v:.42},
  'r&b':{e:.55,d:.72,v:.62},rnb:{e:.55,d:.72,v:.62},
  soul:{e:.55,d:.65,v:.65},funk:{e:.65,d:.82,v:.72},
  jazz:{e:.42,d:.55,v:.62},'jazz fusion':{e:.62,d:.62,v:.58},bebop:{e:.68,d:.58,v:.55},
  blues:{e:.5,v:.35},classical:{e:.35,d:.25},orchestral:{e:.55,d:.3},
  minimalism:{e:.28,d:.2,v:.55},neoclassical:{e:.42,d:.28},
  acoustic:{e:.35},folk:{e:.38,v:.55},country:{e:.55,v:.62},bluegrass:{e:.62,v:.65,d:.58},
  rock:{e:.78,d:.55},'classic rock':{e:.75,d:.58},'indie rock':{e:.65,d:.55,v:.52},
  metal:{e:.92,d:.42,v:.28},'heavy metal':{e:.92,d:.4,v:.25},
  'death metal':{e:.95,d:.38,v:.15},doom:{e:.6,d:.25,v:.18},stoner:{e:.55,v:.42},
  punk:{e:.88,d:.55,v:.45},'post-punk':{e:.62,v:.32},hardcore:{e:.92,v:.28},
  emo:{e:.65,v:.25},shoegaze:{e:.55,v:.42},'dream pop':{e:.45,v:.62,d:.45},
  'post-rock':{e:.65,v:.45},indie:{e:.55,d:.52},alternative:{e:.58},
  pop:{e:.65,d:.72,v:.65},'indie pop':{e:.58,d:.62,v:.62},
  'lo-fi':{e:.28,d:.55,v:.52},lofi:{e:.28,d:.55,v:.52},chillhop:{e:.28,d:.58,v:.55},
  latin:{e:.72,d:.82,v:.72},reggae:{e:.48,d:.75,v:.68},
  reggaeton:{e:.78,d:.88,v:.65},cumbia:{e:.7,d:.85,v:.72},
  salsa:{e:.75,d:.88,v:.78},'bossa nova':{e:.42,d:.62,v:.68},bossa:{e:.42,d:.62,v:.68},
  samba:{e:.72,d:.88,v:.75},afrobeat:{e:.72,d:.82,v:.72},
  gospel:{e:.65,d:.65,v:.82},spiritual:{e:.45,v:.72},
  'new age':{e:.18,d:.2,v:.62},meditation:{e:.12,d:.15,v:.65},
  psychedelic:{e:.62,v:.52},experimental:{e:.55},'avant-garde':{e:.52},
  '80s':{v:.62,d:.72,e:.65},'90s':{v:.55,d:.68,e:.62},oldies:{v:.65,d:.62},
  goth:{e:.55,v:.22},gothic:{e:.55,v:.22},witch:{e:.5,v:.3},
  tribal:{e:.7,d:.78},ceremonial:{e:.5,v:.5},ritual:{e:.48,v:.42},
  shamanic:{e:.52,v:.45},occult:{e:.45,v:.25},
};

function tagsToFeatures(tags){
  let vS=0,eS=0,dS=0,vW=0,eW=0,dW=0;
  for(const tag of tags.slice(0,10)){
    const key=tag.name.toLowerCase().trim();
    const w=Math.max(1,parseInt(tag.count)||1)/100;
    const m=TAG_MAP[key]; if(!m) continue;
    if(m.v!=null){vS+=m.v*w;vW+=w;}
    if(m.e!=null){eS+=m.e*w;eW+=w;}
    if(m.d!=null){dS+=m.d*w;dW+=w;}
  }
  return{valence:vW>0?vS/vW:null,energy:eW>0?eS/eW:null,danceability:dW>0?dS/dW:null};
}

// ── AUDIO PREVIEW ANALYSIS ────────────────────────


// ── COMBINED FEATURES ─────────────────────────────
// ══════════════════════════════════════════════════
// SPOTIFY GENRE ENGINE
// ══════════════════════════════════════════════════

// Spotify genre string → feature weights
// Format: [valence, energy, danceability]  (null = don't influence)
const GENRE_MAP = {
  // emotional valence
  'happy':         [.82,.65,.70], 'sad':           [.18,.35,.40],
  'melancholy':    [.22,.38,.35], 'euphoric':       [.88,.80,.75],
  'dark':          [.20,.60,.40], 'uplifting':      [.78,.72,.68],
  'romantic':      [.62,.45,.55], 'aggressive':     [.35,.88,.60],
  'peaceful':      [.65,.25,.35], 'anxious':        [.30,.65,.45],

  // energy
  'ambient':       [.55,.18,.25], 'drone':          [.40,.15,.20],
  'noise':         [.35,.85,.40], 'industrial':     [.28,.80,.50],
  'shoegaze':      [.45,.55,.38], 'post-rock':      [.48,.60,.38],
  'metal':         [.30,.90,.55], 'hardcore':       [.28,.92,.60],
  'punk':          [.45,.85,.65], 'grunge':         [.35,.75,.55],
  'classical':     [.58,.30,.25], 'orchestral':     [.55,.42,.28],
  'acoustic':      [.60,.32,.42], 'folk':           [.58,.35,.45],

  // dance / rhythm
  'dance':         [.70,.78,.88], 'techno':         [.45,.82,.85],
  'house':         [.65,.80,.88], 'trance':         [.68,.82,.82],
  'drum and bass': [.50,.88,.80], 'jungle':         [.48,.85,.80],
  'dubstep':       [.42,.85,.75], 'trap':           [.40,.78,.80],
  'hip hop':       [.52,.68,.78], 'r&b':            [.62,.60,.72],
  'funk':          [.72,.72,.88], 'soul':           [.65,.58,.68],
  'disco':         [.78,.75,.88], 'reggae':         [.70,.55,.70],
  'dancehall':     [.68,.72,.82], 'afrobeats':      [.72,.78,.88],

  // vibe / texture
  'lo-fi':         [.58,.35,.48], 'chillwave':      [.62,.32,.45],
  'vaporwave':     [.55,.30,.42], 'hyperpop':       [.72,.82,.80],
  'glitch':        [.40,.70,.55], 'experimental':   [.45,.58,.40],
  'electronic':    [.52,.68,.65], 'synth':          [.58,.62,.62],
  'pop':           [.72,.68,.72], 'indie':          [.58,.55,.58],
  'alternative':   [.48,.60,.55], 'post-punk':      [.38,.68,.52],
  'goth':          [.25,.62,.45], 'emo':            [.28,.65,.50],
  'jazz':          [.62,.48,.58], 'blues':          [.45,.52,.58],
  'country':       [.62,.52,.60], 'gospel':         [.72,.65,.62],
  'new age':       [.65,.22,.30], 'meditation':     [.60,.15,.25],
  'club':          [.65,.82,.88], 'party':          [.78,.82,.88],
  'workout':       [.62,.88,.78], 'study':          [.58,.28,.35],
};

function genresToFeatures(genres){
  if(!genres||!genres.length) return null;
  let v=0,e=0,d=0,wt=0;
  for(const g of genres){
    const gl=g.toLowerCase();
    // direct match
    for(const [key,[gv,ge,gd]] of Object.entries(GENRE_MAP)){
      if(gl.includes(key)){
        const w=1;
        v+=gv*w; e+=ge*w; d+=gd*w; wt+=w;
      }
    }
  }
  if(!wt) return null;
  return {
    valence: Math.max(.05,Math.min(.95,v/wt)),
    energy:  Math.max(.05,Math.min(.95,e/wt)),
    danceability: Math.max(.05,Math.min(.95,d/wt)),
  };
}

// artist ID → genres cache (shared across tracks)
const artistGenreCache = {};

async function runGenreEnrichment(){
  if(!lastfmKey){ dbg('no Last.fm key — genre enrichment skipped','warn'); return; }
  dbg('▶ runGenreEnrichment() via Last.fm artist.getTopTags','info');
  dbg(`songs.length=${songs.length}`,'info');

  // Build list of unique artists not yet enriched
  // Group songs by primary artist name (we have this from scan, no Spotify API needed)
  const artistMap = new Map(); // artistName → [songIdx, ...]
  for(let i=0;i<songs.length;i++){
    const s=songs[i];
    if(featureCache[s.id]?._v?.g) continue; // already done
    const artist=cleanArtist(s.artist);
    if(!artistMap.has(artist)) artistMap.set(artist,[]);
    artistMap.get(artist).push(i);
  }

  const alreadyDone=songs.filter(s=>featureCache[s.id]?._v?.g).length;
  dbg(`phase 1: ${artistMap.size} unique artists to enrich (${alreadyDone} already done)`,'info');
  if(!artistMap.size){ dbg('all done ✓','ok'); updateHUD(); return; }

  const GENRE_WORKERS=6; // parallel Last.fm workers
  const artistQueue=[...artistMap.entries()]; // [[artistName, [songIdxs]], ...]
  let fetched=0, withTags=0, emptyTags=0, queueIdx=0;

  async function genreWorker(wId){
    while(true){
      const i=queueIdx++;
      if(i>=artistQueue.length) return;
      const [artistName, songIdxs]=artistQueue[i];

      const url=`https://ws.audioscrobbler.com/2.0/?method=artist.getTopTags&artist=${encodeURIComponent(artistName)}&api_key=${lastfmKey}&format=json&autocorrect=1`;
      let tags=[];
      try{
        const r=await lastfmFetch(url);
        if(r.status===429){ dbg('rate limit — pausing 30s','warn'); await delay(30000); queueIdx--; return; }
        if(!r.ok){ emptyTags++; } else {
          const d=await r.json();
          if(d.error){ emptyTags++; }
          else {
            tags=(d.toptags?.tag||[])
              .slice(0,10)
              .map(t=>t.name?.toLowerCase())
              .filter(Boolean);
          }
        }
      }catch(e){ emptyTags++; }

      // Apply tags to all songs by this artist
      const features=genresToFeatures(tags);
      for(const si of songIdxs){
        const s=songs[si];
        if(!featureCache[s.id]) featureCache[s.id]={};
        featureCache[s.id].genre=features;
        featureCache[s.id].genreTags=tags.slice(0,6);
        if(!featureCache[s.id]._v) featureCache[s.id]._v={};
        featureCache[s.id]._v.g=true;
        if(features&&worldPositions){
          s.f=getFeatures(s);
          const np=computeWorldPos(s,colorMode);
          if(Math.hypot(np.wx-worldPositions[si].wx,np.wy-worldPositions[si].wy)>.005){
            startTransition(si,worldPositions[si],np);
            worldPositions[si]=np;
          }
        }
      }

      fetched++;
      if(tags.length>0) withTags++;
      else emptyTags++;

      // Log every 10 artists
      if(fetched%10===0||fetched===1){
        const ex=tags.slice(0,3).join(', ');
        dbg(`${fetched}/${artistQueue.length} artists · ${withTags} w/tags · e.g. "${artistName}": [${ex||'no tags'}]`,'info');
        queueSave(); updateHUD();
      }
      await delay(jitter(100)); // 6 workers × 100ms ≈ 60 req/s total
    }
  }

  await Promise.all(Array.from({length:GENRE_WORKERS},(_,i)=>genreWorker(i)));

  queueSave(); updateHUD();
  const cs=getGenreChecksum();
  dbg(`✦ done — ${cs.genreReal}/${cs.total} tracks enriched · ${withTags}/${fetched} artists had tags`,'ok');
}

function applyGenresToAll(){
  let applied=0, skipped=0;
  for(const s of songs){
    if(featureCache[s.id]?._v?.g&&featureCache[s.id]._v.g!=='no-id') continue;
    const gdata=artistGenreCache[s.artistId];
    if(!gdata){ skipped++; continue; }
    const features=genresToFeatures(gdata.genres);
    if(!featureCache[s.id]) featureCache[s.id]={};
    featureCache[s.id].genre=features;
    featureCache[s.id].genreTags=gdata.genres.slice(0,6);
    if(!featureCache[s.id]._v) featureCache[s.id]._v={};
    featureCache[s.id]._v.g=true;
    if(features){
      // update position
      const idx=songs.indexOf(s);
      if(idx>=0&&worldPositions){
        const oldPos={...worldPositions[idx]};
        s.f=getFeatures(s);
        const newPos=computeWorldPos(s,colorMode);
        if(Math.hypot(newPos.wx-oldPos.wx,newPos.wy-oldPos.wy)>.005){
          startTransition(idx,oldPos,newPos);
          worldPositions[idx]=newPos;
        }
      }
      applied++;
    } else { skipped++; }
  }
  queueSave();
  updateHUD();
  dbg(`✦ genres applied: ${applied} tracks enriched, ${skipped} no genre data`,'ok');
}

function getGenreChecksum(){
  const total=songs.length;
  const done=songs.filter(s=>featureCache[s.id]?._v?.g).length; // includes no-id
  const real=songs.filter(s=>featureCache[s.id]?._v?.g&&featureCache[s.id]._v.g!=='no-id').length;
  const noId=songs.filter(s=>featureCache[s.id]?._v?.g==='no-id').length;
  const audio=songs.filter(s=>featureCache[s.id]?._v?.a).length;
  return {total,genreDone:done,genreReal:real,genreNoId:noId,audioDone:audio};
}

// ══════════════════════════════════════════════════
// PASSIVE AUDIO ANALYSIS
// ══════════════════════════════════════════════════

let audioCtx=null;
let _audioQueue=[];
let _audioRunning=false;

function queueAudioAnalysis(songIdx){
  if(_audioQueue.includes(songIdx)) return;
  _audioQueue.push(songIdx);
  if(!_audioRunning) drainAudioQueue();
}

async function drainAudioQueue(){
  if(_audioRunning) return; // already running
  _audioRunning=true;
  const AUDIO_WORKERS=5;
  let processed=0;

  async function audioWorker(){
    while(_audioQueue.length){
      const idx=_audioQueue.shift();
      if(idx===undefined) return;
      const s=songs[idx];
      if(!s||featureCache[s.id]?._v?.a) continue;
      const url=s.preview_url||featureCache[s.id]?.previewUrl;
      if(!url) continue;
      await analyzePreview(s, idx, url);
      processed++;
      if(processed%10===0) updateHUD();
      await delay(40);
    }
  }

  await Promise.all(Array.from({length:AUDIO_WORKERS},()=>audioWorker()));
  _audioRunning=false;
  updateHUD();
  const ast=getAudioStats();
  dbg(`✦ audio complete — ${ast.analyzed} analyzed`,'ok');
}

async function analyzePreview(s, songIdx, previewUrl){
  if(!previewUrl) return;
  try{
    if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    const resp=await fetch(previewUrl);
    if(!resp.ok) return;
    const buf=await resp.arrayBuffer();
    const offline=new OfflineAudioContext(1,audioCtx.sampleRate*15,audioCtx.sampleRate);
    const src=offline.createBufferSource();
    src.buffer=await audioCtx.decodeAudioData(buf);
    src.connect(offline.destination);
    src.start(0);
    const rendered=await offline.startRendering();
    const data=rendered.getChannelData(0);

    // RMS energy
    let sum=0; for(let i=0;i<data.length;i++) sum+=data[i]*data[i];
    const rms=Math.sqrt(sum/data.length);
    const energy=Math.min(1,rms*8);

    // Zero crossing rate → brightness proxy
    let zc=0; for(let i=1;i<data.length;i++) if(data[i-1]*data[i]<0) zc++;
    const brightness=Math.min(1,zc/data.length*200);

    // Onset detection → tempo
    const frameSize=1024, hopSize=512;
    const onsets=[];
    let prevEnergy=0;
    for(let i=0;i<data.length-frameSize;i+=hopSize){
      let fe=0; for(let j=i;j<i+frameSize;j++) fe+=data[j]*data[j];
      fe/=frameSize;
      if(fe-prevEnergy>0.002&&onsets.length&&(i-onsets[onsets.length-1])>hopSize*3) onsets.push(i);
      if(fe-prevEnergy>0.002&&!onsets.length) onsets.push(i);
      prevEnergy=fe;
    }
    let tempo=120;
    if(onsets.length>1){
      const iois=onsets.slice(1).map((o,i)=>(o-onsets[i])/audioCtx.sampleRate*1000);
      const med=iois.sort((a,b)=>a-b)[Math.floor(iois.length/2)];
      tempo=Math.round(60000/med);
      if(tempo<60) tempo*=2;
      if(tempo>180) tempo=Math.round(tempo/2);
      tempo=Math.max(60,Math.min(180,tempo));
    }

    const au={energy,brightness,tempo};
    if(!featureCache[s.id]) featureCache[s.id]={};
    featureCache[s.id].audio=au;
    if(!featureCache[s.id]._v) featureCache[s.id]._v={};
    featureCache[s.id]._v.a=true;

    // update position
    if(worldPositions){
      const oldPos={...worldPositions[songIdx]};
      s.f=getFeatures(s);
      const newPos=computeWorldPos(s,colorMode);
      if(Math.hypot(newPos.wx-oldPos.wx,newPos.wy-oldPos.wy)>.005){
        startTransition(songIdx,oldPos,newPos);
        worldPositions[songIdx]=newPos;
      }
    }
    queueSave();
  }catch(e){
    // silent fail — preview might be unavailable or CORS blocked
  }
}

// iTunes preview lookup — no key, CORS-friendly
async function itunesPreview(artist, track){
  try{
    // If track is empty, search by artist only for any song preview
    const q=track
      ? encodeURIComponent(`${artist} ${track}`.trim())
      : encodeURIComponent(artist.trim());
    const entity=track?'song':'musicArtist';
    const r=await fetch(
      `https://itunes.apple.com/search?term=${q}&entity=song&limit=5`,
      {signal:AbortSignal.timeout(8000)});
    if(!r.ok) return null;
    const d=await r.json();
    if(!d.results?.length) return null;
    const al=artist.toLowerCase();
    const tl=track.toLowerCase();
    const ranked=d.results
      .filter(x=>x.previewUrl)
      .map(x=>({
        url:x.previewUrl,
        score:(x.artistName?.toLowerCase().includes(al)?2:0)+
              (track&&x.trackName?.toLowerCase().includes(tl)?2:0)
      }))
      .sort((a,b)=>b.score-a.score);
    return ranked[0]?.url||null;
  }catch{ return null; }
}

// Deezer fallback — CORS proxy needed; use only if iTunes fails
async function deezerPreview(artist, track){
  try{
    const q=encodeURIComponent(`artist:"${cleanArtist(artist)}" track:"${cleanTrack(track)}"`);
    const r=await fetch(`https://api.deezer.com/search?q=${q}&limit=1&output=json`,
      {signal:AbortSignal.timeout(8000)});
    if(!r.ok) return null;
    const d=await r.json();
    return d.data?.[0]?.preview||null;
  }catch{ return null; }
}

// Last.fm track page audio preview (some tracks have streamable previews)
async function lastfmPreview(artist, track){
  try{
    const url=`https://ws.audioscrobbler.com/2.0/?method=track.getInfo&artist=${encodeURIComponent(artist)}&track=${encodeURIComponent(track)}&api_key=${lastfmKey}&format=json`;
    const r=await fetch(url,{signal:AbortSignal.timeout(6000)});
    if(!r.ok) return null;
    const d=await r.json();
    // Some Last.fm tracks include a streamable audio url
    return d.track?.streamable?.fulltrack==='1'? null : null; // placeholder — Last.fm removed streams
  }catch{ return null; }
}

async function resolvePreview(s){
  // 1. Spotify native preview_url
  if(s.preview_url) return s.preview_url;
  // 2. Previously resolved + cached
  if(featureCache[s.id]?.previewUrl) return featureCache[s.id].previewUrl;

  const ca=cleanArtist(s.artist), ct=cleanTrack(s.name);

  // 3. iTunes: artist + track
  const it1=await itunesPreview(ca, ct);
  if(it1){ _cachePreview(s.id,it1); return it1; }

  // 4. iTunes: artist only (broader match for remixes/collabs)
  const it2=await itunesPreview(ca, '');
  if(it2){ _cachePreview(s.id,it2); return it2; }

  // 5. Deezer: artist + track
  const dz=await deezerPreview(ca, ct);
  if(dz){ _cachePreview(s.id,dz); return dz; }

  // 6. Deezer: artist only
  const dz2=await deezerPreview(ca, '');
  if(dz2){ _cachePreview(s.id,dz2); return dz2; }

  // 7. Last.fm track page — some tracks embed a preview stream
  if(lastfmKey){
    const lf=await lastfmPreview(ca, ct);
    if(lf){ _cachePreview(s.id,lf); return lf; }
  }

  return null;
}
function _cachePreview(id, url){
  if(!featureCache[id]) featureCache[id]={};
  featureCache[id].previewUrl=url;
}

async function runPassiveAudioAnalysis(){
  const toAnalyze=songs
    .map((s,i)=>({s,i}))
    .filter(({s})=>!featureCache[s.id]?._v?.a);

  if(!toAnalyze.length){ dbg('audio: all analyzed ✓','ok'); return; }
  toAnalyze.sort(()=>Math.random()-.5);

  const RESOLVE_WORKERS=6;
  dbg(`▶ audio: ${toAnalyze.length} tracks · ${RESOLVE_WORKERS} iTunes workers`,'info');

  const queue=[...toAnalyze];
  let resolved=0, failed=0;
  const resolveToken=_enrichToken;

  async function resolveWorker(){
    while(queue.length){
      if(_enrichToken!==resolveToken) return; // cancelled
      const item=queue.shift();
      if(!item) return;
      const {s,i}=item;
      if(featureCache[s.id]?._v?.a) continue;
      const url=await resolvePreview(s);
      if(url){
        s.preview_url=url;
        queueAudioAnalysis(i);
        resolved++;
        if(resolved%25===0){
          dbg(`audio: ${resolved} previews resolved, ${queue.length} remaining`,'info');
          updateHUD();
        }
      } else { failed++; }
      await delay(70);
    }
  }

  await Promise.all(Array.from({length:RESOLVE_WORKERS},()=>resolveWorker()));
  dbg(`✦ audio resolution done — resolved:${resolved} failed:${failed}`,'ok');
}

function getAudioStats(){
  // count tracks that have a preview URL from any source
  const withPreview=songs.filter(s=>s.preview_url||featureCache[s.id]?.previewUrl).length;
  const analyzed=songs.filter(s=>featureCache[s.id]?._v?.a).length;
  const resolvedExternal=songs.filter(s=>!s.preview_url&&featureCache[s.id]?.previewUrl).length;
  return {withPreview, analyzed, resolvedExternal};
}

function getFeatures(track){
  const s=synth(track);
  const cached=featureCache[track.id]||{};
  const gn=cached.genre, lf=cached.lastfm, au=cached.audio;
  if(!gn&&!lf&&!au) return s;

  let v=s.valence, e=s.energy, d=s.danceability, t=s.tempo;
  let sources=[];

  // genre is highest trust — Spotify's own taxonomy
  if(gn){
    if(gn.valence!=null)      v=s.valence*.08+gn.valence*.92;
    if(gn.energy!=null)       e=s.energy*.08+gn.energy*.92;
    if(gn.danceability!=null) d=s.danceability*.08+gn.danceability*.92;
    sources.push('genre');
  }
  // lastfm blends on top if present
  if(lf){
    const w=gn?.5:.88; // less weight if genre already set
    if(lf.valence!=null) v=v*(1-w)+lf.valence*w;
    if(lf.energy!=null)  e=e*(1-w)+lf.energy*w;
    if(lf.danceability!=null) d=d*(1-w)+lf.danceability*w;
    sources.push('lastfm');
  }
  // audio analysis refines energy + tempo
  if(au){
    const ew=gn?.30:.65;
    e=e*(1-ew)+au.energy*ew;
    t=au.tempo;
    v=Math.max(.02,Math.min(.98,v+(au.brightness-.5)*.06));
    sources.push('audio');
  }

  return{
    valence:Math.max(.02,Math.min(.98,v)),
    energy:Math.max(.02,Math.min(.98,e)),
    danceability:Math.max(.02,Math.min(.98,d)),
    tempo:t,
    genreTags:cached.genreTags||[],
    source:sources.join('+')||'synthetic',
  };
}

// ═══════════════════════════════════════════════════
// AMBIENT STARS
// ═══════════════════════════════════════════════════
(function(){
  const c=document.getElementById('bg-stars'),cx=c.getContext('2d');let stars=[];
  function resize(){c.width=innerWidth;c.height=innerHeight;stars=Array.from({length:200},()=>({x:Math.random()*c.width,y:Math.random()*c.height,r:Math.random()*1.2,a:Math.random(),sp:.001+Math.random()*.002}));}
  function draw(t){cx.clearRect(0,0,c.width,c.height);stars.forEach(s=>{s.a=.2+.3*Math.sin(t*s.sp*1000);cx.beginPath();cx.arc(s.x,s.y,s.r,0,Math.PI*2);cx.fillStyle=`rgba(255,255,255,${s.a})`;cx.fill();});requestAnimationFrame(draw);}
  window.addEventListener('resize',resize);resize();requestAnimationFrame(draw);
})();

// ═══════════════════════════════════════════════════
// AUTH — PKCE
// ═══════════════════════════════════════════════════
function generateRandom(n){const c='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~',a=new Uint8Array(n);crypto.getRandomValues(a);return Array.from(a,b=>c[b%c.length]).join('');}
async function codeChallenge(v){const d=await crypto.subtle.digest('SHA-256',new TextEncoder().encode(v));return btoa(String.fromCharCode(...new Uint8Array(d))).replace(/\+/g,'-').replace(/\//g,'_').replace(/=/g,'');}

async function initiateAuth(){
  const id=document.getElementById('client-id-input').value.trim();
  if(!id||id.length<20){showError('paste your Client ID above ✨');return;}
  clientId=id;lastfmKey=document.getElementById('lastfm-key-input').value.trim()||null;
  localStorage.setItem('rs_client_id',clientId);
  if(lastfmKey) localStorage.setItem('rs_lastfm_key',lastfmKey);
  const verifier=generateRandom(64);localStorage.setItem('rs_verifier',verifier);
  const challenge=await codeChallenge(verifier);
  window.location='https://accounts.spotify.com/authorize?'+new URLSearchParams({
    client_id:clientId,response_type:'code',
    redirect_uri:location.origin+location.pathname,scope:SCOPES,
    code_challenge_method:'S256',code_challenge:challenge,
  });
}
async function exchangeCode(code){
  const r=await fetch('https://accounts.spotify.com/api/token',{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:new URLSearchParams({client_id:clientId,grant_type:'authorization_code',code,redirect_uri:location.origin+location.pathname,code_verifier:localStorage.getItem('rs_verifier')})});
  const d=await r.json();
  if(d.access_token){accessToken=d.access_token;localStorage.setItem('rs_token',accessToken);localStorage.setItem('rs_token_exp',Date.now()+(d.expires_in-600)*1000);localStorage.removeItem('rs_verifier');return true;}
  return false;
}
function showError(msg){const e=document.getElementById('error-msg');e.textContent=msg;e.style.display='block';}

function showBlockedError(){
  const e=document.getElementById('error-msg');
  e.innerHTML=`
    <div style="color:#ff6b6b;margin-bottom:.8rem">⚠ CLIENT ID PUNISHMENT BLOCK DETECTED</div>
    <div style="color:rgba(255,255,255,0.5);font-size:.75rem;line-height:1.7;margin-bottom:1rem">
      Spotify has extended your app's timeout — possibly up to 24 hours.<br>
      Every retry makes it longer. <strong style="color:rgba(255,255,255,0.7)">Stop retrying immediately.</strong>
    </div>
    <div style="color:#a78bfa;font-size:.8rem;line-height:1.8">
      ✦ fastest fix: create a fresh Spotify app (2 min)<br>
      &nbsp;&nbsp;<a href="https://developer.spotify.com/dashboard" target="_blank" style="color:#67e8f9">developer.spotify.com/dashboard</a><br>
      &nbsp;&nbsp;→ Create App → paste new Client ID above<br>
      &nbsp;&nbsp;→ add your redirect URI to the new app<br><br>
      ✦ alternative: wait ~24hrs for this Client ID to unblock
    </div>`;
  e.style.display='block';
  e.style.textAlign='left';
  e.style.padding='1.2rem';
  e.style.background='rgba(255,50,50,0.05)';
  e.style.border='1px solid rgba(255,100,100,0.2)';
  e.style.borderRadius='8px';
}
async function parseToken(){
  const p=new URLSearchParams(location.search),code=p.get('code'),err=p.get('error');
  if(err){showError(`Spotify: ${err}`);return false;}
  if(code){
    clientId=localStorage.getItem('rs_client_id');
    history.replaceState({},'',location.pathname);
    show('loading-screen');hide('login-screen');
    setLoadStatus('AUTHENTICATING...',0);
    if(!await exchangeCode(code)){hide('loading-screen');show('login-screen');showError('auth failed — try again 💫');return false;}
    return true;
  }
  const stored=localStorage.getItem('rs_token'),exp=parseInt(localStorage.getItem('rs_token_exp')||'0');
  if(stored&&Date.now()<exp){accessToken=stored;clientId=localStorage.getItem('rs_client_id');return true;}
  return false;
}

// ═══════════════════════════════════════════════════
// SPOTIFY API
// ═══════════════════════════════════════════════════
const delay=ms=>new Promise(r=>setTimeout(r,ms));
let _lastApiCall=0;
let _reqCount=0;
let _tracksLoadedSoFar=0; // so we can detect if we're blocked before any data

function jitter(ms){ return ms + Math.floor(Math.random()*ms*0.4); } // ±40% jitter

// Adaptive throttle — starts cautious, backs off hard on any 429
let _throttleMs = 2000; // start at 2s = 30 req/min (bulletproof conservative)
const THROTTLE_MIN = 1500;
const THROTTLE_MAX = 8000;
function onSuccess(){ _throttleMs = Math.max(THROTTLE_MIN, _throttleMs * 0.98); } // slowly speed up if all good
function onRateLimit(){ _throttleMs = Math.min(THROTTLE_MAX, _throttleMs * 2.5); } // back off hard on 429

async function apiGet(url, _retries=0){
  if(!accessToken){ dbg('apiGet: no access token','err'); throw new Error('auth_expired'); }
  const minGap=jitter(_throttleMs);
  const now=Date.now(), gap=now-_lastApiCall;
  if(gap<minGap) await delay(minGap-gap);
  setLoadDetail(`throttle: ${(_throttleMs/1000).toFixed(1)}s/req · ${_reqCount} calls made`);
  _lastApiCall=Date.now();
  _reqCount++;

  let r;
  try{
    const controller=new AbortController();
    const tid=setTimeout(()=>controller.abort(),20000);
    r=await fetch(url,{headers:{Authorization:`Bearer ${accessToken}`},signal:controller.signal});
    clearTimeout(tid);
  }catch(e){
    if(e.name==='AbortError'){
      dbg(`apiGet timeout: ${url.slice(0,60)}`,'warn');
      throw new Error('Request timed out — check connection');
    }
    dbg(`apiGet fetch error: ${e.message}`,'warn');
    throw new Error('auth_expired');
  }

  if(r.status===401){
    dbg('Spotify 401 — token expired, re-auth needed','err');
    throw new Error('auth_expired');
  }
  if(r.status===403){
    // 403 can be endpoint restriction, not always token expiry
    // Log it but throw a distinct error so callers can choose to retry
    dbg(`Spotify 403 on ${url.slice(url.lastIndexOf('/')+1,url.lastIndexOf('/')+30)} — forbidden (scope/endpoint restriction)`,'warn');
    throw new Error('forbidden_403');
  }

  if(r.status===429){
    const retryAfterHeader=r.headers.get('Retry-After');
    const isPunishmentBlock=(_tracksLoadedSoFar===0 && _reqCount<=2);
    onRateLimit();
    if(isPunishmentBlock){
      dbg('Spotify 429 on first calls — Client ID punishment block','err');
      throw new Error('CLIENT_ID_BLOCKED');
    }
    let waitSecs;
    if(retryAfterHeader){
      waitSecs=parseInt(retryAfterHeader);
      if(waitSecs>=3600){ dbg('Spotify 429 Retry-After >1hr — punishment block','err'); throw new Error('CLIENT_ID_BLOCKED'); }
      dbg(`Spotify 429 rate limit — Retry-After: ${waitSecs}s`,'warn');
      setLoadDetail(`HTTP 429 · Retry-After: ${waitSecs}s`);
    } else {
      waitSecs=jitter(Math.pow(2,_retries+1)*10);
      dbg(`Spotify 429 rate limit — backoff ${waitSecs}s`,'warn');
      setLoadDetail(`HTTP 429 · no header · backoff ${waitSecs}s`);
    }
    if(_retries>=3){ dbg('Spotify 429 — max retries reached','err'); throw new Error('rate_limited_hard'); }
    for(let i=waitSecs;i>0;i--){
      const pct=(waitSecs-i)/waitSecs;
      const filled=Math.floor(pct*20);
      const bar='█'.repeat(filled)+'░'.repeat(20-filled);
      setLoadStatus(`⏳ RATE LIMITED · resuming in ${i}s  [${bar}]`,0.01);
      await delay(1000);
    }
    setLoadStatus('RESUMING SCAN...',0.01);
    setLoadDetail('');
    _lastApiCall=0;
    return apiGet(url, _retries+1);
  }

  if(!r.ok){
    dbg(`Spotify HTTP ${r.status}: ${url.slice(0,60)}`,'warn');
    throw new Error(`Spotify HTTP ${r.status}`);
  }
  try{
    const json=await r.json();
    onSuccess();
    return json;
  }catch(e){ dbg('apiGet JSON parse error','warn'); throw new Error('auth_expired'); }
}


function setLoadDetail(msg){
  const el=document.getElementById('load-detail');
  if(el) el.textContent=msg;
}
function abortAndReturn(){
  localStorage.removeItem('rs_token');localStorage.removeItem('rs_token_exp');
  hide('loading-screen');show('login-screen');
}
const SCAN_CACHE_KEY='rs_scan_v2'; // v2: includes artistId

function saveScanProgress(tracks, nextUrl, total){
  try{
    localStorage.setItem(SCAN_CACHE_KEY, JSON.stringify({tracks,nextUrl,total,savedAt:Date.now()}));
  }catch(e){
    // storage full — save just IDs+minimal data
    try{
      const slim=tracks.map(t=>({id:t.id,name:t.name,artist:t.artist,artistId:t.artistId||null,uri:t.uri,url:t.url,preview_url:t.preview_url,popularity:t.popularity,duration_ms:t.duration_ms}));
      localStorage.setItem(SCAN_CACHE_KEY, JSON.stringify({tracks:slim,nextUrl,total,savedAt:Date.now()}));
    }catch{}
  }
}

function loadScanProgress(){
  try{
    // Migrate: clear old v1 cache if v2 key is now active
    if(SCAN_CACHE_KEY==='rs_scan_v2') localStorage.removeItem('rs_scan_v1');
    const raw=localStorage.getItem(SCAN_CACHE_KEY);
    if(!raw) return null;
    const p=JSON.parse(raw);
    return p;
  }catch{ return null; }
}

async function fetchAllLiked(){
  // resume from saved progress if available
  const saved=loadScanProgress();
  let tracks=saved?.tracks||[];
  let nextUrl=saved?.nextUrl||('https://api.spotify.com/v1/me/tracks?limit=50');
  let total=saved?.total||null;

  if(tracks.length>0 && saved?.nextUrl){
    setLoadStatus(`RESUMING SCAN FROM ${tracks.length} TRACKS...`,tracks.length/(total||10000));
    await delay(1000);
  } else if(tracks.length>0 && !saved?.nextUrl){
    // already complete!
    setLoadStatus(`LIBRARY LOADED FROM CACHE (${tracks.length} tracks)`,1);
    await delay(500);
    return tracks;
  } else {
    setLoadStatus('SCANNING YOUR LIBRARY...',0);
  }

  while(nextUrl){
    try{
      const d=await apiGet(nextUrl);
      if(!total) total=d.total;
      const newTracks=d.items
        .filter(i=>i.track&&i.track.id)
        .map(i=>({
          id:i.track.id, name:i.track.name,
          artist:i.track.artists.map(a=>a.name).join(', '),
          artistId:i.track.artists[0]?.id||null,  // primary artist ID for genre fetch
          uri:i.track.uri, url:i.track.external_urls.spotify,
          preview_url:i.track.preview_url,
          popularity:i.track.popularity||50,
          duration_ms:i.track.duration_ms||200000,
        }));
      tracks.push(...newTracks);
      _tracksLoadedSoFar=tracks.length;
      nextUrl=d.next||null;
      const pagesLeft=nextUrl?Math.ceil((total-tracks.length)/50):0;
      const etaSecs=pagesLeft*(_throttleMs/1000);
      const etaStr=etaSecs>60?`~${Math.round(etaSecs/60)}min left`:`~${Math.round(etaSecs)}s left`;
      const eta=pagesLeft>0?` · ${etaStr}`:'';
      setLoadStatus(`RECEIVING TRANSMISSIONS... ${tracks.length.toLocaleString()} / ${total.toLocaleString()}${eta}`,tracks.length/total);
      setLoadDetail(`page ${Math.ceil(tracks.length/50)} of ${Math.ceil(total/50)} · throttle: ${(_throttleMs/1000).toFixed(1)}s/req`);
      if(tracks.length%500===0) saveScanProgress(tracks, nextUrl, total);
    }catch(e){
      if(e.message==='rate_limited_hard'){
        // save where we are and ask user to come back
        saveScanProgress(tracks, nextUrl, total);
        throw new Error(`Rate limited after ${tracks.length} tracks. Progress saved! Open the portal again in a few minutes to continue.`);
      }
      throw e;
    }
  }
  // complete — save with null nextUrl so we know it's done
  saveScanProgress(tracks, null, total);
  return tracks;
}

// ═══════════════════════════════════════════════════
// LASTFM PROGRESSIVE ENRICHMENT
// ═══════════════════════════════════════════════════
let enrichActive=false;
let enrichError=null;
let enrichConsecFails=0;
let _enrichToken=0;

function setEnrichError(msg){
  enrichError=msg;
  const btn=document.getElementById('settings-btn');
  const block=document.getElementById('sp-error-block');
  const msgEl=document.getElementById('sp-error-msg');
  if(btn) { btn.classList.toggle('has-error', !!msg); btn.textContent=msg?'⚑':'⚙'; }
  if(block) block.style.display=msg?'block':'none';
  if(msgEl&&msg) msgEl.textContent=msg;
  updateSettingsPanel();
}

// Clean Spotify's messy naming for Last.fm queries
function cleanArtist(artist){
  return artist
    .split(/,|feat\.|ft\.|&|\//i)[0]  // take only first artist
    .replace(/\s*\(.*?\)\s*/g,'')      // remove parentheticals
    .replace(/\s*\[.*?\]\s*/g,'')      // remove brackets
    .trim();
}

function cleanTrack(track){
  return track
    .replace(/\s*[\(\[].*(feat|ft|with|prod|remix|edit|remaster|version|live|acoustic|radio|bonus|explicit|clean|mono|stereo|demo|single|extended|original|alt|alternate|anniversary|deluxe|session|cover|tribute|instrumental|karaoke|reprise|interlude).*[\)\]]/gi,'')
    .replace(/\s*-\s*(feat|ft|with|prod|remix|edit|remaster|version|live|acoustic|radio|bonus|explicit|mono|stereo|demo|single|extended|original|alt|alternate|anniversary|deluxe|session|cover|tribute|instrumental|karaoke|reprise|interlude).*/gi,'')
    .replace(/\s*[\(\[].*[\)\]]$/g,'') // remove any remaining trailing parens
    .trim();
}

// Build Last.fm URL with cleaned names
function lastfmTagUrl(artist, track, apiKey){
  const a=encodeURIComponent(cleanArtist(artist));
  const t=encodeURIComponent(cleanTrack(track));
  return `https://ws.audioscrobbler.com/2.0/?method=track.getTopTags&artist=${a}&track=${t}&api_key=${apiKey}&format=json&autocorrect=1`;
}

async function lastfmFetch(url){
  const controller=new AbortController();
  const tid=setTimeout(()=>controller.abort(),10000);
  try{
    const r=await fetch(url,{signal:controller.signal});
    clearTimeout(tid); return r;
  }catch(e){
    clearTimeout(tid);
    if(e.name==='AbortError') throw new Error('timeout');
    throw e;
  }
}

async function runEnrichment(){
  if(!lastfmKey){ dbg('no lastfmKey — enrichment skipped','warn'); return; }
  if(enrichActive){ dbg(`already active — ignoring`,'warn'); return; }
  enrichActive=true;
  enrichConsecFails=0;
  const myToken=++_enrichToken;
  setEnrichError(null);

  const WORKERS=8; // parallel workers
  const toProcess=songs.filter(s=>!featureCache[s.id]?.lastfm);
  dbg(`▶ lastfm: ${toProcess.length} tracks · ${WORKERS} workers (token ${myToken})`,'info');
  updateHUD();

  let idx=0, foundCount=0, skippedCount=0;
  const skipReasons={};
  function logSkip(r){ skipReasons[r]=(skipReasons[r]||0)+1; }

  async function worker(wId){
    while(true){
      if(_enrichToken!==myToken) return; // cancelled
      const i=idx++;
      if(i>=toProcess.length) return; // done
      const s=toProcess[i];

      // progress log every 100 tracks (across all workers)
      if(i%100===0){
        dbg(`${i}/${toProcess.length} found:${foundCount} skipped:${skippedCount}`,'info');
        updateHUD();
      }
      // skip breakdown every 250
      if(skippedCount>0&&skippedCount%250===0){
        const summary=Object.entries(skipReasons).map(([k,v])=>`${k}:${v}`).join(' | ');
        dbg(`skip breakdown — ${summary}`,'warn');
      }

      const attempts=[
        ()=>lastfmTagUrl(s.artist, s.name, lastfmKey),
        ()=>lastfmTagUrl(cleanArtist(s.artist), s.name, lastfmKey),
        ()=>lastfmTagUrl(s.artist, s.name.split(/[\(\[-]/)[0], lastfmKey),
      ];

      let d=null, fetchOk=false;
      for(let attempt=0;attempt<attempts.length;attempt++){
        const url=attempts[attempt]();
        let r;
        try{ r=await lastfmFetch(url); }
        catch(fe){
          enrichConsecFails++;
          if(enrichConsecFails>=20){ dbg('20 consecutive fails — stopping','err'); setEnrichError('Network issues — Open Settings → Retry.'); enrichActive=false; _enrichToken++; return; }
          await delay(800); break;
        }
        if(r.status===401||r.status===403){ dbg(`HTTP ${r.status} — key rejected`,'err'); setEnrichError(`Last.fm key rejected`); enrichActive=false; _enrichToken++; return; }
        if(r.status===429){ dbg('rate limited 60s','warn'); setEnrichError('Last.fm rate limit — pausing 60s...'); await delay(60000); setEnrichError(null); attempt--; continue; }
        if(!r.ok){ logSkip(`http-${r.status}`); skippedCount++; fetchOk=true; break; }

        let parsed;
        try{ parsed=await r.json(); }
        catch(je){ logSkip('json-fail'); skippedCount++; fetchOk=true; break; }

        if(parsed.error){
          if(parsed.error===6||parsed.error===7||parsed.error===8){
            if(attempt<attempts.length-1){ await delay(60); continue; }
            logSkip(`err${parsed.error}-not-found`); skippedCount++;
          } else if([4,9,10,13,14,26].includes(parsed.error)){
            dbg(`fatal lastfm error ${parsed.error}`,'err'); setEnrichError(`Last.fm error ${parsed.error}`); enrichActive=false; _enrichToken++; return;
          } else if(parsed.error===11||parsed.error===16){
            await delay(2000); attempt--; continue;
          } else { logSkip(`err${parsed.error}`); skippedCount++; }
          fetchOk=true; break;
        }

        d=parsed; fetchOk=true; break;
      }

      if(!fetchOk||!d){ skippedCount++; continue; }

      const tags=(d.toptags?.tag||[]).slice(0,8).map(t=>t.name?.toLowerCase()).filter(Boolean);
      if(!tags.length){ logSkip('no-tags'); skippedCount++; continue; }

      // map tags to features
      const tagFeatures={valence:null,energy:null,danceability:null};
      const MOOD_MAP={'happy':[.8,.65,.7],'sad':[.2,.35,.4],'energetic':[.6,.88,.75],'calm':[.6,.25,.3],'aggressive':[.3,.88,.6],'romantic':[.65,.4,.55],'melancholy':[.2,.38,.35],'euphoric':[.88,.8,.75],'dark':[.2,.6,.4],'uplifting':[.78,.72,.68]};
      let wt=0;
      for(const tag of tags){
        for(const [k,[v,e,d2]] of Object.entries(MOOD_MAP)){
          if(tag.includes(k)){ tagFeatures.valence=(tagFeatures.valence||0)+v; tagFeatures.energy=(tagFeatures.energy||0)+e; tagFeatures.danceability=(tagFeatures.danceability||0)+d2; wt++; }
        }
      }
      if(wt>0){ tagFeatures.valence/=wt; tagFeatures.energy/=wt; tagFeatures.danceability/=wt; }
      else { tagFeatures.valence=null; tagFeatures.energy=null; tagFeatures.danceability=null; }

      if(!featureCache[s.id]) featureCache[s.id]={};
      featureCache[s.id].lastfm={...tagFeatures, tags};
      featureCache[s.id].tags=tags;
      enrichConsecFails=0;
      foundCount++;
      s.f=getFeatures(s);
      const si=songs.indexOf(s);
      if(si>=0&&worldPositions){
        const np=computeWorldPos(s,colorMode);
        startTransition(si,worldPositions[si],np);
        worldPositions[si]=np;
      }
      if(foundCount%50===0){ queueSave(); updateHUD(); }
      await delay(jitter(70)); // 8 workers × 70ms ≈ 11 tracks/s
    }
  }

  // Launch all workers concurrently
  await Promise.all(Array.from({length:WORKERS},(_,i)=>worker(i)));

  if(_enrichToken===myToken){
    queueSave();
    const summary=Object.entries(skipReasons).map(([k,v])=>`${k}:${v}`).join(' | ');
    dbg(`✦ lastfm done — found:${foundCount} skipped:${skippedCount} | ${summary||'clean'}`,'ok');
    enrichActive=false; setEnrichError(null); updateHUD();
  }
}

function retryEnrichment(){
  _enrichToken++;
  enrichActive=false;
  enrichConsecFails=0;
  setEnrichError(null);
  toggleSettings();
  setTimeout(runEnrichment, 600);         // last.fm
  setTimeout(runGenreEnrichment, 1200);   // genre
}

// ── ON-DEMAND AUDIO ANALYSIS ──────────────────────
let audioQueue=new Set();
async function requestAudioAnalysis(songIdx){
  if(audioQueue.has(songIdx)) return;
  const s=songs[songIdx];
  if(!s?.preview_url||featureCache[s.id]?.audio) return;
  audioQueue.add(songIdx);
  const au=await analyzePreview(s.preview_url);
  if(au){
    if(!featureCache[s.id]) featureCache[s.id]={};
    featureCache[s.id].audio=au;
    const oldPos=worldPositions?{...worldPositions[songIdx]}:null;
    s.f=getFeatures(s);
    if(oldPos&&worldPositions){
      const newPos=computeWorldPos(s,colorMode);
      if(Math.hypot(newPos.wx-oldPos.wx,newPos.wy-oldPos.wy)>.005){startTransition(songIdx,oldPos,newPos);worldPositions[songIdx]=newPos;}
    }
    queueSave();
    if(hoveredSong===songIdx) showTooltip(s,mouseX,mouseY);
    if(pinnedSong===songIdx) showSongCard(s);
  }
  audioQueue.delete(songIdx);
}

// ═══════════════════════════════════════════════════
// VISUALIZATION
// ═══════════════════════════════════════════════════
const canvas=document.getElementById('viz-canvas');
const gridCanvas=document.getElementById('grid-canvas');
const gctx=gridCanvas.getContext('2d'); // lightweight 2D for grid + hover rings
let gl=null, glProg=null;
// WebGL attribute/uniform locations (cached at init)
let _aPos, _aColor, _aSize, _aAlpha, _aGlow;
let _uRes, _uCamX, _uCamY, _uZoom;
// Pre-allocated GPU arrays (reused every frame)
let _gpuPos=null, _gpuColor=null, _gpuSize=null, _gpuAlpha=null, _gpuGlow=null;
let _bufPos, _bufColor, _bufSize, _bufAlpha, _bufGlow;

// ═══════════════════════════════════════════════════
// WEBGL RENDERER
// ═══════════════════════════════════════════════════
const VERT_SRC=`
  attribute vec2 a_pos;
  attribute vec3 a_col;
  attribute float a_sz;
  attribute float a_alpha;
  attribute float a_glow;
  uniform vec2 u_res;
  uniform float u_cx;
  uniform float u_cy;
  uniform float u_zoom;
  varying vec3 v_col;
  varying float v_alpha;
  varying float v_glow;
  void main(){
    // apply camera: zoom around center then pan
    float canvasCx=u_res.x*.5;
    float canvasCy=u_res.y*.5;
    float px=(a_pos.x-canvasCx)*u_zoom+canvasCx+u_cx;
    float py=(a_pos.y-canvasCy)*u_zoom+canvasCy+u_cy;
    vec2 clip=(vec2(px,py)/u_res)*2.0-1.0;
    gl_Position=vec4(clip*vec2(1,-1),0,1);
    gl_PointSize=clamp(a_sz*u_zoom,1.0,80.0);
    v_col=a_col; v_alpha=a_alpha; v_glow=a_glow;
  }
`;
const FRAG_SRC=`
  precision mediump float;
  varying vec3 v_col;
  varying float v_alpha;
  varying float v_glow;
  void main(){
    vec2 coord=gl_PointCoord-vec2(0.5);
    float dist=length(coord);
    if(dist>0.5) discard;
    // dual-layer glow: tight core + soft halo
    float core=smoothstep(0.5,0.05,dist);
    float halo=smoothstep(0.5,0.3,dist)*0.4*v_glow;
    float alpha=v_alpha*(core+halo);
    gl_FragColor=vec4(v_col,alpha);
  }
`;

function hslToRgb(h,s,l){
  s/=100; l/=100;
  const k=n=>(n+h/30)%12;
  const a=s*Math.min(l,1-l);
  const f=n=>l-a*Math.max(-1,Math.min(k(n)-3,Math.min(9-k(n),1)));
  return[f(0),f(8),f(4)];
}
function parseHsl(hslStr){
  // parses "hsl(H,S%,L%)" → [r,g,b] 0..1
  const m=hslStr.match(/hsl\(([^,]+),([^%]+)%,([^%]+)%\)/);
  if(!m) return[.5,.5,.5];
  return hslToRgb(parseFloat(m[1]),parseFloat(m[2]),parseFloat(m[3]));
}

function initWebGL(){
  gl=canvas.getContext('webgl',{premultipliedAlpha:false,alpha:true});
  if(!gl){ console.warn('WebGL unavailable — falling back to 2D'); return false; }

  function compileShader(type,src){
    const sh=gl.createShader(type);
    gl.shaderSource(sh,src); gl.compileShader(sh);
    if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)){
      console.error('Shader error:',gl.getShaderInfoLog(sh)); return null;
    }
    return sh;
  }
  const vert=compileShader(gl.VERTEX_SHADER,VERT_SRC);
  const frag=compileShader(gl.FRAGMENT_SHADER,FRAG_SRC);
  glProg=gl.createProgram();
  gl.attachShader(glProg,vert); gl.attachShader(glProg,frag);
  gl.linkProgram(glProg);
  if(!gl.getProgramParameter(glProg,gl.LINK_STATUS)){
    console.error('Program link error:',gl.getProgramInfoLog(glProg)); return false;
  }
  gl.useProgram(glProg);

  // Cache attribute locations
  _aPos=gl.getAttribLocation(glProg,'a_pos');
  _aColor=gl.getAttribLocation(glProg,'a_col');
  _aSize=gl.getAttribLocation(glProg,'a_sz');
  _aAlpha=gl.getAttribLocation(glProg,'a_alpha');
  _aGlow=gl.getAttribLocation(glProg,'a_glow');

  // Cache uniform locations
  _uRes=gl.getUniformLocation(glProg,'u_res');
  _uCamX=gl.getUniformLocation(glProg,'u_cx');
  _uCamY=gl.getUniformLocation(glProg,'u_cy');
  _uZoom=gl.getUniformLocation(glProg,'u_zoom');

  // Create buffers
  _bufPos=gl.createBuffer(); _bufColor=gl.createBuffer();
  _bufSize=gl.createBuffer(); _bufAlpha=gl.createBuffer();
  _bufGlow=gl.createBuffer();

  // Additive blending — cluster glow accumulates like real light
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA,gl.ONE);

  return true;
}

function bindAttr(buf, loc, data, size){
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,data,gl.DYNAMIC_DRAW);
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc,size,gl.FLOAT,false,0,0);
}


function launchViz(){
  hide('loading-screen');canvas.classList.remove('hidden');showHUD();
  songs.forEach(s=>{s.f=getFeatures(s);});
  worldPositions=songs.map(s=>computeWorldPos(s,colorMode));
  updateAxisLabels(colorMode);
  updateHUD();
  // Init WebGL (falls back gracefully if unavailable)
  const webglOk=initWebGL();
  if(!webglOk) console.warn('WebGL init failed — running without GPU acceleration');
  resizeCanvas();
  window.addEventListener('resize',resizeCanvas);
  setupInteraction();resetView();renderLoop();
  // Checksum: determine what enrichment pipelines still need to run
  setTimeout(()=>{
    const cs=getGenreChecksum();
    dbg(`checksum — genre:${cs.genreDone}/${cs.total} audio:${cs.audioDone}/${cs.total}`,'info');

    // Genre uses Last.fm artist.getTopTags — no Spotify API needed
    if(cs.genreDone < cs.total){
      if(lastfmKey) runGenreEnrichment();
      else dbg('no Last.fm key — add one in settings to enable genre enrichment','warn');
    } else dbg('genre: fully cached ✓','ok');

    // Passive audio — start after genre to avoid API collision
    setTimeout(()=>{
      const ast=getAudioStats();
      dbg(`audio check: ${ast.analyzed} analyzed, ${ast.withPreview} have preview_url (will also try iTunes/Deezer)`,'info');
      if(ast.analyzed >= songs.length) dbg('audio: all tracks analyzed ✓','ok');
      else runPassiveAudioAnalysis(); // always run — will resolve via iTunes/Deezer for missing previews
    }, cs.genreDone < cs.total ? 30000 : 2000); // wait for genre if it's running

    // Last.fm still runs if key present (catches anything genre misses)
    if(lastfmKey) setTimeout(runEnrichment, 5000);
  }, 2000);
}
function resizeCanvas(){
  const w=innerWidth, h=innerHeight;
  canvas.width=w; canvas.height=h;
  gridCanvas.width=w; gridCanvas.height=h;
  if(gl) gl.viewport(0,0,w,h);
}

// Axis config per mode — what each filter maps to X and Y
const MODE_AXES = {
  genre: { x:'valence', y:'energy',      xl:'MELANCHOLY', xr:'EUPHORIC',  yb:'MELLOW',  yt:'ENERGETIC' },
  energy:{ x:'valence', y:'energy',      xl:'MELANCHOLY', xr:'EUPHORIC',  yb:'MELLOW',  yt:'ENERGETIC' },
  tempo: { x:'valence', y:'tempo',       xl:'MELANCHOLY', xr:'EUPHORIC',  yb:'SLOW',    yt:'FAST'      },
  dance: { x:'danceability', y:'energy', xl:'STILL',      xr:'DANCEABLE', yb:'MELLOW',  yt:'ENERGETIC' },
};

function getAxisFeature(f, key){
  if(key==='tempo') return Math.max(0,Math.min(1,(f.tempo-60)/140));
  return f[key]||0;
}

function computeWorldPos(s, mode){
  const f=s.f||getFeatures(s), m=.07;
  const ax=MODE_AXES[mode||colorMode]||MODE_AXES.genre;
  let hx=0,hy=0;
  for(let ch of s.id){hx=Math.imul(31,hx)+ch.charCodeAt(0)|0;hy=Math.imul(37,hy)+ch.charCodeAt(0)|0;}
  const jx=(Math.sin(hx*7.3)*43758.5%1-.5)*.016;
  const jy=(Math.sin(hy*3.7)*43758.5%1-.5)*.016;
  const xv=getAxisFeature(f,ax.x);
  const yv=getAxisFeature(f,ax.y);
  return{wx:m+xv*(1-m*2)+jx, wy:(1-m)-yv*(1-m*2)+jy};
}

function updateAxisLabels(mode){
  const ax=MODE_AXES[mode]||MODE_AXES.genre;
  document.getElementById('ax-left').textContent=ax.xl;
  document.getElementById('ax-right').textContent=ax.xr;
  document.getElementById('ax-bottom').textContent=ax.yb;
  document.getElementById('ax-top').textContent=ax.yt;
}
function startTransition(idx,from,to){
  posTransitions[idx]={fx:from.wx,fy:from.wy,tx:to.wx,ty:to.wy,start:performance.now(),dur:1800+Math.random()*600};
}
function getPos(idx){
  const t=posTransitions[idx];if(!t) return worldPositions[idx];
  const p=Math.min(1,(performance.now()-t.start)/t.dur);
  const e=p<.5?4*p*p*p:1-Math.pow(-2*p+2,3)/2;
  if(p>=1){delete posTransitions[idx];return worldPositions[idx];}
  return{wx:t.fx+(t.tx-t.fx)*e,wy:t.fy+(t.ty-t.fy)*e};
}
function worldToScreen(wx,wy){
  const cx=canvas.width/2,cy=canvas.height/2,sz=Math.min(canvas.width,canvas.height)*.85;
  return{sx:cx+(wx-.5)*sz*camZoom+camX,sy:cy+(wy-.5)*sz*camZoom+camY};
}
function getColor(s,mode){
  const f=s.f;if(!f) return '#888';
  const v=f.valence,e=f.energy,d=f.danceability,t=Math.max(0,Math.min(1,(f.tempo-60)/140));
  if(mode==='energy'){
    // blue (calm) → purple → magenta → orange → yellow (intense)
    const h=260-e*220; const sat=60+e*35; const lit=30+e*35;
    return`hsl(${h},${sat}%,${lit}%)`;
  }
  if(mode==='tempo'){
    // deep blue (slow) → teal → green → yellow → red (fast)
    const h=240-t*240; return`hsl(${h},80%,${40+t*25}%)`;
  }
  if(mode==='dance'){
    // full spectrum rainbow by danceability + energy brightness
    // still=cool blues, danceable=hot pinks/oranges/yellows
    const h=(d*300+e*60)%360;
    const sat=55+d*40;
    const lit=30+d*25+e*15;
    return`hsl(${h},${sat}%,${lit}%)`;
  }
  // SONIC: hue from valence (blue=sad→red/orange=happy), brightness from energy
  const hue=220+v*160; // 220=blue(melancholy) → 380=red/pink(euphoric)
  return`hsl(${hue%360},${55+d*30}%,${30+e*35}%)`;
}
function getSize(s){return 1.5+(s.f?.danceability||.5)*3.5;}

function render(){
  // ── WebGL: draw 10k song points ──────────────────────
  if(!gl){
    // 2D fallback (no WebGL)
    const ctx2=canvas.getContext('2d');
    ctx2.clearRect(0,0,canvas.width,canvas.height);
    const q2=searchQuery.toLowerCase();
    for(let i=0;i<songs.length;i++){
      const s=songs[i];
      const{wx,wy}=getPos(i);
      const{sx,sy}=worldToScreen(wx,wy);
      if(sx<-20||sx>canvas.width+20||sy<-20||sy>canvas.height+20) continue;
      const r=getSize(s)*Math.max(.5,Math.min(2,camZoom*.8));
      const col=getColor(s,colorMode);
      const isHov=hoveredSong===i||pinnedSong===i;
      const isMatch=q2&&(s.name.toLowerCase().includes(q2)||s.artist.toLowerCase().includes(q2));
      const isDim=q2&&!isMatch;
      const isCryst=!!(featureCache[s.id]?.lastfm||featureCache[s.id]?.audio);
      ctx2.globalAlpha=isDim?.04:isHov?1:isCryst?.88:.62;
      ctx2.shadowBlur=isHov?22:isCryst?4:0; ctx2.shadowColor=col;
      ctx2.beginPath();ctx2.arc(sx,sy,isHov?r*2.2:r,0,Math.PI*2);
      ctx2.fillStyle=col;ctx2.fill();
    }
    ctx2.globalAlpha=1;ctx2.shadowBlur=0;
  }
  if(gl){
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.clearColor(0,0,0,0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    const n=songs.length;
    // Allocate/reuse flat GPU arrays
    if(!_gpuPos||_gpuPos.length!==n*2){
      _gpuPos=new Float32Array(n*2);
      _gpuColor=new Float32Array(n*3);
      _gpuSize=new Float32Array(n);
      _gpuAlpha=new Float32Array(n);
      _gpuGlow=new Float32Array(n);
    }

    const q=searchQuery.toLowerCase();
    const canvasCx=canvas.width/2, canvasCy=canvas.height/2;
    const sz=Math.min(canvas.width,canvas.height)*.85;

    for(let i=0;i<n;i++){
      const s=songs[i];
      const{wx,wy}=getPos(i);
      // pixel position (camera applied in vertex shader)
      _gpuPos[i*2]  =canvasCx+(wx-.5)*sz;
      _gpuPos[i*2+1]=canvasCy+(wy-.5)*sz;

      const col=getColor(s,colorMode);
      const rgb=parseHsl(col);
      _gpuColor[i*3]=rgb[0]; _gpuColor[i*3+1]=rgb[1]; _gpuColor[i*3+2]=rgb[2];

      const baseSize=getSize(s)*2.2;
      const isHov=hoveredSong===i||pinnedSong===i;
      _gpuSize[i]=isHov?baseSize*2.4:baseSize;

      const isMatch=q&&(s.name.toLowerCase().includes(q)||s.artist.toLowerCase().includes(q));
      const isDim=q&&!isMatch;
      const isCryst=!!(featureCache[s.id]?.lastfm||featureCache[s.id]?.audio||featureCache[s.id]?.genre);
      _gpuAlpha[i]=isDim?.03:isHov?.95:isCryst?.82:.52;
      _gpuGlow[i]=isHov?1.0:isMatch?.8:(isCryst?.5:.15);
    }

    bindAttr(_bufPos,  _aPos,   _gpuPos,   2);
    bindAttr(_bufColor,_aColor, _gpuColor, 3);
    bindAttr(_bufSize, _aSize,  _gpuSize,  1);
    bindAttr(_bufAlpha,_aAlpha, _gpuAlpha, 1);
    bindAttr(_bufGlow, _aGlow,  _gpuGlow,  1);

    // Camera uniforms (cached locations, set every frame — cheap)
    gl.uniform2f(_uRes, canvas.width, canvas.height);
    gl.uniform1f(_uCamX, camX);
    gl.uniform1f(_uCamY, camY);
    gl.uniform1f(_uZoom, camZoom);

    gl.drawArrays(gl.POINTS, 0, n);
  }

  // ── 2D grid-canvas overlay: grid lines + hover ring + transit rings ──
  const gw=gridCanvas.width, gh=gridCanvas.height;
  gctx.clearRect(0,0,gw,gh);

  // Grid lines
  gctx.strokeStyle='rgba(255,255,255,0.025)'; gctx.lineWidth=1;
  for(let g=.1;g<1;g+=.1){
    const{sx}=worldToScreen(g,0),{sy}=worldToScreen(0,g);
    gctx.beginPath(); gctx.moveTo(sx,0); gctx.lineTo(sx,gh); gctx.stroke();
    gctx.beginPath(); gctx.moveTo(0,sy); gctx.lineTo(gw,sy); gctx.stroke();
  }
  // Center crosshairs
  gctx.strokeStyle='rgba(167,139,250,0.08)'; gctx.lineWidth=1.5;
  const{sx:ccx,sy:ccy}=worldToScreen(.5,.5);
  gctx.beginPath(); gctx.moveTo(0,ccy); gctx.lineTo(gw,ccy); gctx.stroke();
  gctx.beginPath(); gctx.moveTo(ccx,0); gctx.lineTo(ccx,gh); gctx.stroke();

  // Hover / pinned ring
  const hi=hoveredSong!==null?hoveredSong:(pinnedSong!==null?pinnedSong:-1);
  if(hi>=0){
    const hs=songs[hi];
    const{wx,wy}=getPos(hi);
    const{sx,sy}=worldToScreen(wx,wy);
    const hr=getSize(hs)*Math.max(.5,Math.min(2,camZoom*.8));
    const hcol=getColor(hs,colorMode);
    gctx.globalAlpha=.22;
    gctx.beginPath(); gctx.arc(sx,sy,hr*4.8,0,Math.PI*2);
    gctx.strokeStyle=hcol; gctx.lineWidth=.8; gctx.stroke();
    gctx.globalAlpha=1;
  }

  // Transit pulse rings (songs currently moving)
  const now=performance.now();
  for(const[idx,t] of Object.entries(posTransitions)){
    const i=parseInt(idx);
    if(i<0||i>=songs.length) continue;
    const{wx,wy}=getPos(i);
    const{sx,sy}=worldToScreen(wx,wy);
    const pr=getSize(songs[i])*Math.max(.5,Math.min(2,camZoom*.8));
    gctx.globalAlpha=.35+.25*Math.sin(now*.004);
    gctx.beginPath(); gctx.arc(sx,sy,pr*2,0,Math.PI*2);
    gctx.strokeStyle='rgba(255,255,255,0.6)'; gctx.lineWidth=.5; gctx.stroke();
  }
  gctx.globalAlpha=1;
}

let _raf=null;
function renderLoop(){render();_raf=requestAnimationFrame(renderLoop);}

// ═══════════════════════════════════════════════════
// INTERACTION
// ═══════════════════════════════════════════════════
function setupInteraction(){
  canvas.addEventListener('mousemove',onMouseMove);
  canvas.addEventListener('mousedown',onMouseDown);
  canvas.addEventListener('mouseup',onMouseUp);
  canvas.addEventListener('mouseleave',()=>{isDragging=false;hideTooltip();hoveredSong=null;});
  canvas.addEventListener('wheel',onWheel,{passive:false});
  canvas.addEventListener('click',onCanvasClick);
  canvas.addEventListener('touchstart',onTouchStart,{passive:false});
  canvas.addEventListener('touchmove',onTouchMove,{passive:false});
  canvas.addEventListener('touchend',onTouchEnd,{passive:false});
  document.getElementById('sc-open-btn').addEventListener('click',()=>{if(songCardUrl)window.open(songCardUrl,'_blank');});
}
function getTouchCenter(ts){return ts.length===1?{x:ts[0].clientX,y:ts[0].clientY}:{x:(ts[0].clientX+ts[1].clientX)/2,y:(ts[0].clientY+ts[1].clientY)/2};}
function getTouchDist(ts){return Math.hypot(ts[0].clientX-ts[1].clientX,ts[0].clientY-ts[1].clientY);}
function onTouchStart(e){
  e.preventDefault();touchMoved=false;
  if(e.touches.length===1){const t=e.touches[0];isDragging=true;dragStartX=touchStartX=t.clientX;dragStartY=touchStartY=t.clientY;dragCamX=camX;dragCamY=camY;lastTouchDist=null;}
  else if(e.touches.length===2){isDragging=false;lastTouchDist=getTouchDist(e.touches);const c=getTouchCenter(e.touches);dragStartX=c.x;dragStartY=c.y;dragCamX=camX;dragCamY=camY;}
}
function onTouchMove(e){
  e.preventDefault();touchMoved=true;
  if(e.touches.length===1&&isDragging){const t=e.touches[0];camX=dragCamX+(t.clientX-dragStartX);camY=dragCamY+(t.clientY-dragStartY);hideSongCard();hoveredSong=-1;}
  else if(e.touches.length===2){
    const nd=getTouchDist(e.touches),c=getTouchCenter(e.touches);
    if(lastTouchDist!==null){const f=nd/lastTouchDist,wx=c.x-canvas.width/2,wy=c.y-canvas.height/2;camX=(camX-wx)*f+wx;camY=(camY-wy)*f+wy;camZoom=Math.max(.3,Math.min(30,camZoom*f));}
    camX=dragCamX+(c.x-dragStartX);camY=dragCamY+(c.y-dragStartY);
    lastTouchDist=nd;dragCamX=camX-(c.x-dragStartX);dragCamY=camY-(c.y-dragStartY);dragStartX=c.x;dragStartY=c.y;
  }
}
function onTouchEnd(e){
  e.preventDefault();isDragging=false;lastTouchDist=null;
  if(!touchMoved&&e.changedTouches.length===1){const t=e.changedTouches[0];if(Math.abs(t.clientX-touchStartX)<8&&Math.abs(t.clientY-touchStartY)<8)handleTap(t.clientX,t.clientY);}
}
function handleTap(x,y){
  let closest=-1,bestD=Infinity;
  for(let i=0;i<songs.length;i++){const{sx,sy}=worldToScreen(getPos(i).wx,getPos(i).wy);const d=Math.hypot(x-sx,y-sy);if(d<32&&d<bestD){bestD=d;closest=i;}}
  if(closest>=0){pinnedSong=closest;hoveredSong=closest;showSongCard(songs[closest]);requestAudioAnalysis(closest);}
  else{pinnedSong=-1;hoveredSong=-1;hideSongCard();}
}
let hoverAudioTimer=null;
function onMouseMove(e){
  mouseX=e.clientX;mouseY=e.clientY;
  if(isDragging){camX=dragCamX+(e.clientX-dragStartX);camY=dragCamY+(e.clientY-dragStartY);hideTooltip();hoveredSong=null;return;}
  let closest=-1,bestD=Infinity;
  for(let i=0;i<songs.length;i++){const{sx,sy}=worldToScreen(getPos(i).wx,getPos(i).wy);const d=Math.hypot(e.clientX-sx,e.clientY-sy);if(d<18&&d<bestD){bestD=d;closest=i;}}
  if(closest!==hoveredSong){
    hoveredSong=closest;clearTimeout(hoverAudioTimer);
    if(closest>=0){showTooltip(songs[closest],e.clientX,e.clientY);canvas.style.cursor='pointer';hoverAudioTimer=setTimeout(()=>requestAudioAnalysis(closest),600);}
    else{hideTooltip();canvas.style.cursor='crosshair';}
  }else if(closest>=0) moveTooltip(e.clientX,e.clientY);
}
function onMouseDown(e){isDragging=true;dragStartX=e.clientX;dragStartY=e.clientY;dragCamX=camX;dragCamY=camY;canvas.style.cursor='grabbing';}
function onMouseUp(){isDragging=false;canvas.style.cursor='crosshair';}
function onWheel(e){
  e.preventDefault();
  const f=e.deltaY<0?1.12:.89,wx=e.clientX-canvas.width/2,wy=e.clientY-canvas.height/2;
  camX=(camX-wx)*f+wx;camY=(camY-wy)*f+wy;camZoom=Math.max(.3,Math.min(30,camZoom*f));
}
function onCanvasClick(e){
  if(Math.abs(e.clientX-dragStartX)>5||Math.abs(e.clientY-dragStartY)>5) return;
  if(hoveredSong>=0) window.open(songs[hoveredSong].url,'_blank');
}

// ── TOOLTIP ──
const tooltip=document.getElementById('tooltip');
function getSourceLabel(s){
  const c=featureCache[s.id];
  if(!c) return '⬡ seeded · hover to analyze audio';
  const parts=[];
  if(c.lastfm&&c.tags) parts.push('◈ '+c.tags.slice(0,3).join(' · '));
  if(c.audio) parts.push('◉ audio analyzed');
  const idx=songs.indexOf(s);
  if(audioQueue.has(idx)) parts.push('⟳ analyzing...');
  else if(s.preview_url&&!c.audio) parts.push('· hover to analyze');
  return parts.join(' ')||'⬡ seeded';
}
function showTooltip(s,x,y){
  document.getElementById('tt-artist').textContent=s.artist;
  document.getElementById('tt-track').textContent=s.name;
  const f=s.f;
  document.getElementById('tt-stats').innerHTML=`
    <div class="tt-stat">ENERGY <span>${Math.round(f.energy*100)}%</span></div>
    <div class="tt-stat">VALENCE <span>${Math.round(f.valence*100)}%</span></div>
    <div class="tt-stat">DANCE <span>${Math.round(f.danceability*100)}%</span></div>
    <div class="tt-stat">BPM <span>${Math.round(f.tempo)}</span></div>`;
  document.querySelector('.tt-hint').textContent=getSourceLabel(s);
  moveTooltip(x,y);tooltip.classList.add('visible');
}
function moveTooltip(x,y){
  const w=260;let tx=x;
  if(tx+w/2>innerWidth-10)tx=innerWidth-10-w/2;
  if(tx-w/2<10)tx=10+w/2;
  tooltip.style.left=tx+'px';tooltip.style.top=(y-15)+'px';
}
function hideTooltip(){tooltip.classList.remove('visible');}

function showSongCard(s){
  const card=document.getElementById('song-card');card.style.display='block';
  document.getElementById('sc-artist').textContent=s.artist;
  document.getElementById('sc-track').textContent=s.name;
  const f=s.f,c=featureCache[s.id];
  const tags=c?.tags?`<div class="sc-stat" style="width:100%;margin-top:.4rem;color:rgba(255,255,255,0.35)">${c.tags.slice(0,4).join(' · ')}</div>`:'';
  document.getElementById('sc-stats').innerHTML=`
    <div class="sc-stat">ENERGY <span>${Math.round(f.energy*100)}%</span></div>
    <div class="sc-stat">VALENCE <span>${Math.round(f.valence*100)}%</span></div>
    <div class="sc-stat">DANCE <span>${Math.round(f.danceability*100)}%</span></div>
    <div class="sc-stat">BPM <span>${Math.round(f.tempo)}</span></div>${tags}`;
  songCardUrl=s.url;
  requestAnimationFrame(()=>card.classList.add('visible'));
}
function hideSongCard(){
  const card=document.getElementById('song-card');card.classList.remove('visible');
  setTimeout(()=>{if(!card.classList.contains('visible'))card.style.display='none';},350);
}

// ── HELPERS ──
function updateHUD(){
  const el=document.getElementById('hud-count');if(!el)return;
  const total=songs.length;
  const cs=getGenreChecksum();
  const ast=getAudioStats();
  const lfDone=songs.filter(s=>featureCache[s.id]?.lastfm).length;

  // Unified crystallization score: weight genre 40%, lastfm 35%, audio 25%
  const genrePct = cs.genreReal / total;
  const lfPct    = lfDone / total;
  const audioPct = ast.withPreview>0 ? ast.analyzed/ast.withPreview : (ast.analyzed>0?1:0);
  const crystalPct = Math.round((genrePct*.40 + lfPct*.35 + audioPct*.25)*100);

  let status;
  if(crystalPct>=99) status='✦ crystallized';
  else if(crystalPct>0) status=`crystallizing ${crystalPct}%`;
  else status='awaiting crystallization';

  el.textContent=`${total.toLocaleString()} songs · ${status}`;
}

function rescanLibrary(){
  if(!confirm('Rescan library from Spotify? Your Last.fm, genre, and audio analysis data will be preserved.')) return;
  localStorage.removeItem(SCAN_CACHE_KEY);
  localStorage.removeItem('rs_scan_v1'); // clear old key too
  // Note: intentionally NOT clearing rs_token so user stays logged in
  location.reload();
}
function setLoadStatus(msg,progress){
  document.getElementById('load-status').textContent=msg;
  document.getElementById('load-progress-fill').style.width=`${Math.round(progress*100)}%`;
  const pct=Math.round(progress*100);
  const reqInfo=_reqCount>0?` · ${_reqCount} API calls`:'';
  document.getElementById('load-count').textContent=`${pct}% complete${reqInfo}`;
}
// ── SETTINGS PANEL ──────────────────────────────
let settingsOpen=false;

// ── DEBUG LOG ──
const _dbgLines=[];

let _debugOpen=false;

function dbg(msg, type='info'){
  const t=new Date().toLocaleTimeString('en',{hour12:false,hour:'2-digit',minute:'2-digit',second:'2-digit'});
  const line={t,msg,type};
  _dbgLines.push(line);
  if(_dbgLines.length>120) _dbgLines.shift();
  console.log(`[RS ${type.toUpperCase()}] ${msg}`); // also goes to browser console
  if(_debugOpen) renderDebugLog();
  // surface errors automatically — show flag even if panel closed
  if(type==='err') setEnrichError(msg);
}


function renderDebugLog(){
  const el=document.getElementById('sp-debug');
  if(!el) return;
  el.innerHTML=_dbgLines.slice().reverse().map(l=>
    `<div class="dbg-line dbg-${l.type}">${l.t} ${l.msg}</div>`
  ).join('');
}

function toggleDebugLog(){
  _debugOpen=!_debugOpen;
  const el=document.getElementById('sp-debug');
  const btn=document.getElementById('sp-debug-toggle');
  if(!el||!btn) return;
  if(_debugOpen){
    el.style.display='block';
    btn.textContent='▾ HIDE DEBUG LOG';
    renderDebugLog();
    setTimeout(()=>el.scrollTop=0,50);
  } else {
    el.style.display='none';
    btn.textContent='▸ SHOW DEBUG LOG';
  }
}

function toggleSettings(){
  settingsOpen=!settingsOpen;
  const panel=document.getElementById('settings-panel');
  if(!panel) return;
  if(settingsOpen){
    updateSettingsPanel();
    panel.style.display='block';
    // keep refreshing while open
    if(!_settingsRefreshTimer) _settingsRefreshTimer=setInterval(updateSettingsPanel,2000);
  } else {
    panel.style.display='none';
    clearInterval(_settingsRefreshTimer); _settingsRefreshTimer=null;
  }
}
let _settingsRefreshTimer=null;

function updateSettingsPanel(){
  const cid=document.getElementById('sp-client-id');
  const lfk=document.getElementById('sp-lastfm-key');
  const cst=document.getElementById('sp-crystal-status');
  const stored_cid=localStorage.getItem('rs_client_id')||clientId;
  const stored_lfk=localStorage.getItem('rs_lastfm_key')||lastfmKey;
  if(cid) cid.textContent=stored_cid?stored_cid.slice(0,8)+'...'+ stored_cid.slice(-4):'not set';
  if(lfk) lfk.textContent=stored_lfk?stored_lfk.slice(0,6)+'...'+ stored_lfk.slice(-4):'not set — crystallization disabled';
  if(cst){
    const cs=getGenreChecksum();
    const ast=getAudioStats();
    const lfDone=songs.filter(s=>featureCache[s.id]?.lastfm).length;
    const total=songs.length;
    const genrePct=cs.genreReal/total;
    const lfPct=lfDone/total;
    const audioPct=ast.withPreview>0?ast.analyzed/ast.withPreview:(ast.analyzed>0?1:0);
    const overall=Math.round((genrePct*.40+lfPct*.35+audioPct*.25)*100);
    const filled=Math.round(overall/5);
    const bar='█'.repeat(filled)+'░'.repeat(20-filled);
    const running=enrichActive||_audioRunning;
    const statusLine=overall>=99?'✦ complete':`${bar} ${overall}%${running?' · running':''}`;
    const details=[];
    details.push(`tags ${lfDone.toLocaleString()}/${total.toLocaleString()}`);
    details.push(`genre ${cs.genreReal.toLocaleString()}/${total.toLocaleString()}`);
    if(ast.withPreview>0||ast.analyzed>0) details.push(`audio ${ast.analyzed.toLocaleString()}${ast.withPreview>0?'/'+ast.withPreview.toLocaleString():''}`);
    cst.innerHTML=`<div style="letter-spacing:.04em;margin-bottom:4px">${statusLine}</div><div style="opacity:.5;font-size:.48rem">${details.join(' · ')}</div>`;
  }
}

function logOut(){
  // clear auth tokens only — preserve ALL cache data
  localStorage.removeItem('rs_token');
  localStorage.removeItem('rs_token_exp');
  // keep: rs_client_id, rs_lastfm_key, rs_features_v4, rs_scan_v1
  settingsOpen=false;
  document.getElementById('settings-panel').style.display='none';
  // hide viz, show login
  const canvas=document.getElementById('viz-canvas');
  canvas.style.transition='opacity 0.4s';
  canvas.style.opacity='0';
  setTimeout(()=>{
    canvas.classList.add('hidden');
    canvas.style.opacity='1';
    canvas.style.transition='';
    ['hud','legend','controls','color-mode','search-wrap','ax-top','ax-bottom','ax-left','ax-right','settings-btn'].forEach(id=>{
      const el=document.getElementById(id);
      if(el){ el.classList.add('hidden'); el.style.display=''; }
    });
    document.getElementById('settings-btn').style.display='none';
    show('login-screen');
  },420);
}

// close settings panel when clicking outside
document.addEventListener('click',(e)=>{
  if(!settingsOpen) return;
  const panel=document.getElementById('settings-panel');
  const btn=document.getElementById('settings-btn');
  if(panel&&btn&&!panel.contains(e.target)&&!btn.contains(e.target)){
    settingsOpen=false;
    panel.style.display='none';
  }
});

function resetView(){camX=0;camY=0;camZoom=1;}
function zoomIn(){camZoom=Math.min(30,camZoom*1.4);}
function zoomOut(){camZoom=Math.max(.3,camZoom/1.4);}
let _modeTransitioning=false;

function setColorMode(mode){
  if(colorMode===mode||_modeTransitioning) return;
  _modeTransitioning=true;
  const prev=colorMode;
  colorMode=mode;

  // Update button states with pulse
  document.querySelectorAll('.mode-btn').forEach(b=>b.classList.remove('active','switching'));
  const activeBtn=document.getElementById(`cm-${mode}`);
  activeBtn.classList.add('active','switching');
  setTimeout(()=>activeBtn.classList.remove('switching'),400);

  // Update axis labels immediately
  updateAxisLabels(mode);

  // Shimmer fade-out, reposition, fade back in
  const canvas=document.getElementById('viz-canvas');
  canvas.style.transition='opacity 0.25s ease';
  canvas.style.opacity='0.15';

  // Stagger star transitions — recompute all positions for new mode
  setTimeout(()=>{
    if(worldPositions){
      songs.forEach((s,i)=>{
        // add slight stagger per star so they ripple outward
        const delay=Math.random()*400;
        setTimeout(()=>{
          const oldPos={...getPos(i)};
          const newPos=computeWorldPos(s,mode);
          const dist=Math.hypot(newPos.wx-oldPos.wx,newPos.wy-oldPos.wy);
          if(dist>.002){
            posTransitions[i]={
              fx:oldPos.wx,fy:oldPos.wy,
              tx:newPos.wx,ty:newPos.wy,
              start:performance.now(),
              dur:600+Math.random()*800, // 600-1400ms per star
            };
            worldPositions[i]=newPos;
          }
        }, delay);
      });
    }
    // fade back in
    canvas.style.opacity='1';
    setTimeout(()=>{ canvas.style.transition=''; _modeTransitioning=false; },500);
  },260);
}
function handleSearch(val){searchQuery=val;}
function show(id){document.getElementById(id).classList.remove('hidden');}
function hide(id){document.getElementById(id).classList.add('hidden');}
function showHUD(){
  ['hud','legend','controls','color-mode','search-wrap','ax-top','ax-bottom','ax-left','ax-right'].forEach(show);
  const sb=document.getElementById('settings-btn');
  if(sb) sb.style.display='flex';
}

// ═══════════════════════════════════════════════════
// BOOT
// ═══════════════════════════════════════════════════
async function boot(){
  loadFeatureCache();
  clientId=localStorage.getItem('rs_client_id');
  lastfmKey=localStorage.getItem('rs_lastfm_key');
  if(clientId) document.getElementById('client-id-input').value=clientId;
  if(lastfmKey) document.getElementById('lastfm-key-input').value=lastfmKey;
  const hasToken=await parseToken();
  if(!hasToken) return;
  show('loading-screen');hide('login-screen');
  setTimeout(()=>{const b=document.getElementById('load-back-btn');if(b)b.style.display='block';},10000);
  setLoadStatus('OPENING CHANNEL...',0);
  await delay(1500); // brief pause so Spotify rate limit window resets
  try{
    const tracks=await fetchAllLiked();
    setLoadStatus('CRYSTALLIZING...',.95);
    songs=tracks.map(t=>({...t,f:getFeatures(t)}));
    await delay(400);
    launchViz();
  }catch(e){
    hide('loading-screen');show('login-screen');
    if(e.message==='CLIENT_ID_BLOCKED'){
      localStorage.removeItem('rs_token');localStorage.removeItem('rs_token_exp');
      showBlockedError();
    }else if(e.message==='auth_expired'||e.message.includes('fetch')){
      localStorage.removeItem('rs_token');localStorage.removeItem('rs_token_exp');
      showError('session expired ✨ tap the portal again');
    }else if(e.message.includes('Rate limited after')){
      showError(e.message);
    }else{
      localStorage.removeItem('rs_token');localStorage.removeItem('rs_token_exp');
      showError(`${e.message} — try again 💫`);
    }
  }
}
boot();
</script>
</body>
</html>
